

import os
import io
import base64
import threading
import time
from datetime import datetime, timedelta, timezone

import pandas as pd
import plotly.graph_objects as go
from sqlalchemy import create_engine, text

import logging
from logging.handlers import TimedRotatingFileHandler

from dash import Dash, dcc, html, Input, Output, State, callback_context, no_update
import dash_bootstrap_components as dbc

# --- CONFIG ---
try:
    from config import DB_CONFIG, TOTAL_CAPACITY, RESERVED_PERCENT
except ImportError:
    print("WARNING: config.py not found. Using defaults.")
    DB_CONFIG = {"user": "postgres", "password": "password", "host": "localhost", "port": "5432", "dbname": "capacity_db"}
    TOTAL_CAPACITY = {"CPU": 1000, "RAM": 5000, "STORAGE": 500} # Storage in TB
    RESERVED_PERCENT = 0.15

# --- LOGGING ---
logger = logging.getLogger("capacity_dashboard")
logger.setLevel(logging.INFO)
handler = TimedRotatingFileHandler("capacity.log", when="midnight", backupCount=7)
handler.setFormatter(logging.Formatter("%(asctime)s - %(levelname)s - %(message)s"))
if not logger.handlers: logger.addHandler(handler)

# --- DB ENGINE ---
ENGINE = create_engine(
    f"postgresql+psycopg2://{DB_CONFIG['user']}:{DB_CONFIG['password']}@"
    f"{DB_CONFIG['host']}:{DB_CONFIG['port']}/{DB_CONFIG['dbname']}",
    pool_pre_ping=True
)

# --- CONSTANTS ---
INVENTORY_STATUS = ("Running", "Running/Not in Production")
INVENTORY_LOCATION = "NJ Datacenter"
INVENTORY_TYPE = "Server/VM"
REFRESH_MS = 30 * 60 * 1000  # 30 Minutes
RUN_RECONCILER = os.environ.get("RUN_RECONCILER", "true").lower() in ("true", "1", "yes")
RECONCILE_INTERVAL = 300
GLOBAL_THRESHOLDS = {"cpu_abs":1, "ram_mb_abs":512, "storage_gb_abs":5, "pct_tolerance":0.20}
COLORS = {"background": "#f4f6f9", "cpu": "#4e73df", "ram": "#1cc88a", "storage": "#6f42c1"}

# --- AUTO-FIX DATABASE SCHEMA ---
def fix_schema():
    try:
        with ENGINE.begin() as conn:
            conn.execute(text("ALTER TABLE capacity_events ADD COLUMN IF NOT EXISTS pending_inventory BOOLEAN DEFAULT TRUE"))
            conn.execute(text("ALTER TABLE capacity_events ADD COLUMN IF NOT EXISTS reconciled BOOLEAN DEFAULT FALSE"))
            conn.execute(text("ALTER TABLE capacity_events ADD COLUMN IF NOT EXISTS reconciled_at TIMESTAMP"))
    except: pass
fix_schema()

# --- HELPERS ---
def now_utc(): return datetime.now(timezone.utc)
def fmt_cpu(v): return f"{int(round(float(v or 0))):,} Cores"
def fmt_ram_gb(v): return f"{float(v or 0):,.1f} GB"
def fmt_storage_tb(v): return f"{(float(v or 0)/1024.0):,.2f} TB"

def parse_csv(contents, filename):
    if not contents: raise ValueError("No file")
    header, content_string = contents.split(",", 1)
    decoded = base64.b64decode(content_string)
    df = pd.read_csv(io.StringIO(decoded.decode("utf-8")))
    lc = [c.lower() for c in df.columns]
    if not {"date", "server", "cpu", "ram", "storage"}.issubset(set(lc)):
        raise ValueError("Headers must be: date, server, cpu, ram, storage")
    mapping = {orig: orig.lower() for orig in df.columns}
    df = df.rename(columns=mapping)
    df["date"] = pd.to_datetime(df["date"], errors="coerce").dropna()
    df["server"] = df["server"].astype(str)
    for c in ["cpu", "ram", "storage"]: df[c] = pd.to_numeric(df[c], errors="coerce").fillna(0)
    return df.rename(columns={"ram": "ram_gb", "storage": "storage_gb"})

def detect_and_convert_ram_sum_to_gb(raw_sum, raw_max, baseline_gb):
    try: rs = float(raw_sum); rm = float(raw_max)
    except: return 0.0
    if baseline_gb <= 0: return rs / 1024.0 if abs(rm) > 5000 else rs
    if abs(rm) > abs(baseline_gb) * 10 or abs(rm) > 5000: return rs / 1024.0
    return rs

# --- CORE LOGIC ---
def calculate_capacity():
    try:
        inv = pd.read_sql(text("""
            SELECT COALESCE(SUM(NULLIF(TRIM(servercores), '')::numeric),0) AS cpu,
                   COALESCE(SUM(NULLIF(TRIM(servermemory), '')::numeric)/1024.0,0) AS ram_gb,
                   COALESCE(SUM(NULLIF(TRIM(totaldisk), '')::numeric),0) AS storage_gb
            FROM inventory WHERE assetstatus IN (:s1, :s2) AND assetlocation = :loc AND assettype = :atype
        """), ENGINE, params={"s1": INVENTORY_STATUS[0], "s2": INVENTORY_STATUS[1], "loc": INVENTORY_LOCATION, "atype": INVENTORY_TYPE})
        base_cpu = float(inv["cpu"].iloc[0] or 0)
        base_ram = float(inv["ram_gb"].iloc[0] or 0)
        base_stg = float(inv["storage_gb"].iloc[0] or 0)
    except: base_cpu = base_ram = base_stg = 0.0

    try:
        ev = pd.read_sql(text("""
            SELECT COALESCE(SUM(cpu_delta) FILTER (WHERE reconciled = false), 0) AS cpu_sum,
                   COALESCE(SUM(ram_delta_gb) FILTER (WHERE reconciled = false), 0) AS ram_sum_raw,
                   COALESCE(MAX(ABS(ram_delta_gb)) FILTER (WHERE reconciled = false), 0) AS ram_max_raw,
                   COALESCE(SUM(storage_delta_gb) FILTER (WHERE reconciled = false), 0) AS storage_sum
            FROM capacity_events
        """), ENGINE)
        cpu_sum = float(ev["cpu_sum"].iloc[0] or 0)
        ram_sum = float(ev["ram_sum_raw"].iloc[0] or 0)
        ram_max = float(ev["ram_max_raw"].iloc[0] or 0)
        stg_sum = float(ev["storage_sum"].iloc[0] or 0)
    except: cpu_sum = ram_sum = ram_max = stg_sum = 0.0

    used_cpu = base_cpu + cpu_sum
    used_ram = base_ram + detect_and_convert_ram_sum_to_gb(ram_sum, ram_max, base_ram)
    used_stg = base_stg + stg_sum
    total_stg_gb = TOTAL_CAPACITY.get("STORAGE", 0) * 1024.0

    def mk_kpi(used, total):
        reserved = total * RESERVED_PERCENT
        usable = max(total - reserved, 0)
        pct = (used / usable * 100) if usable > 0 else 0
        return {"used": used, "total": total, "reserved": reserved, "available": max(usable - used, 0), "pct": pct}

    return {
        "CPU": mk_kpi(used_cpu, TOTAL_CAPACITY.get("CPU", 0)),
        "RAM": mk_kpi(used_ram, TOTAL_CAPACITY.get("RAM", 0)),
        "STORAGE": mk_kpi(used_stg, total_stg_gb)
    }

def build_gauge(title, value, max_val, color):
    if max_val <= 0: max_val = 1
    # Detail Text: "500 of 1,000"
    detail = f"{int(value):,} / {int(max_val):,}"
    
    fig = go.Figure(go.Indicator(
        mode = "gauge+number",
        value = value,
        domain = {'x': [0, 1], 'y': [0, 1]},
        title = {'text': f"{title}<br><span style='font-size:0.5em;color:gray'>{detail}</span>", 'font': {'size': 18, 'color': "darkblue"}},
        gauge = {
            'axis': {'range': [None, max_val], 'tickwidth': 1, 'tickcolor': "darkblue"},
            'bar': {'color': color},
            'bgcolor': "white", 'borderwidth': 2, 'bordercolor': "gray",
            'steps': [{'range': [0, max_val*0.75], 'color': 'rgba(240, 240, 240, 0.5)'}, {'range': [max_val*0.75, max_val], 'color': 'rgba(255, 0, 0, 0.1)'}],
            'threshold': {'line': {'color': "red", 'width': 4}, 'thickness': 0.75, 'value': max_val * 0.9}
        }
    ))
    fig.update_layout(height=260, margin=dict(l=30,r=30,t=50,b=20), paper_bgcolor='rgba(0,0,0,0)', font={'color': "darkblue"})
    return fig

def build_top_consumers(resource):
    col_map = {"CPU": "servercores", "RAM": "servermemory", "STORAGE": "totaldisk"}
    col = col_map.get(resource)
    try:
        sql = f"SELECT assetuniquename, NULLIF(TRIM({col}), '')::numeric as val FROM inventory WHERE assetstatus IN (:s1, :s2) ORDER BY val DESC NULLS LAST LIMIT 5"
        df = pd.read_sql(text(sql), ENGINE, params={"s1":INVENTORY_STATUS[0], "s2":INVENTORY_STATUS[1]})
        if df.empty: return go.Figure()
        
        if resource == "RAM":
            df["val"] = df["val"] / 1024.0
            unit = "GB"
        elif resource == "STORAGE":
            unit = "GB"
        else:
            unit = "Cores"

        fig = go.Figure(go.Bar(x=df["val"], y=df["assetuniquename"], orientation='h', marker=dict(color=COLORS[resource.lower()], opacity=0.8)))
        fig.update_layout(title=f"Top 5 {resource} Consumers", yaxis=dict(autorange="reversed"), xaxis_title=unit, template="plotly_white", height=250, margin=dict(l=10,r=10,t=40,b=20))
        return fig
    except: return go.Figure()

# --- RECONCILER ---
_reconcile_lock = threading.Lock()
def auto_reconcile_pending_events():
    matched = 0
    try:
        if not _reconcile_lock.acquire(blocking=False): return
        df = pd.read_sql(text("SELECT id, assetuniquename, cpu_delta, ram_delta_gb, storage_delta_gb FROM capacity_events WHERE pending_inventory = true AND reconciled = false"), ENGINE)
        for _, row in df.iterrows():
            inv = pd.read_sql(text("SELECT servercores, servermemory, totaldisk FROM inventory WHERE assetuniquename = :s LIMIT 1"), ENGINE, params={"s": row["assetuniquename"]})
            if inv.empty: continue
            
            i_cpu = float(inv.iloc[0]["servercores"] or 0)
            i_ram = float(inv.iloc[0]["servermemory"] or 0)
            i_stg = float(inv.iloc[0]["totaldisk"] or 0)
            e_cpu = float(row["cpu_delta"] or 0); e_ram = float(row["ram_delta_gb"] or 0); e_stg = float(row["storage_delta_gb"] or 0)
            e_ram_mb = e_ram if abs(e_ram) > 1024 else e_ram * 1024.0
            t = GLOBAL_THRESHOLDS
            
            if ((abs(e_cpu - i_cpu) <= t["cpu_abs"] or abs(e_cpu - i_cpu) <= t["pct_tolerance"]*i_cpu) and 
                (abs(e_ram_mb - i_ram) <= t["ram_mb_abs"] or abs(e_ram_mb - i_ram) <= t["pct_tolerance"]*i_ram) and 
                (abs(e_stg - i_stg) <= t["storage_gb_abs"] or abs(e_stg - i_stg) <= t["pct_tolerance"]*i_stg)):
                with ENGINE.begin() as conn:
                    conn.execute(text("UPDATE capacity_events SET reconciled=true, pending_inventory=false, reconciled_at=now() WHERE id=:id"), {"id": row["id"]})
                matched += 1
        return matched
    except: pass
    finally: 
        if _reconcile_lock.locked(): _reconcile_lock.release()

if RUN_RECONCILER:
    def run_recon_loop():
        time.sleep(5)
        while True:
            auto_reconcile_pending_events()
            time.sleep(RECONCILE_INTERVAL)
    threading.Thread(target=run_recon_loop, daemon=True).start()

def insert_event(server, cpu, ram_mb, storage_gb, source, date=None, pending=True):
    try:
        with ENGINE.begin() as conn:
            conn.execute(text("INSERT INTO capacity_events (assetuniquename, cpu_delta, ram_delta_gb, storage_delta_gb, source, event_time, pending_inventory, reconciled) VALUES (:s, :c, :r, :st, :src, :et, :p, false)"), 
                         {"s": server, "c": cpu, "r": ram_mb, "st": storage_gb, "src": source, "et": date or now_utc(), "p": pending})
        return True, "OK"
    except Exception as e: return False, str(e)

def delete_event(event_id):
    try:
        with ENGINE.begin() as conn:
            res = conn.execute(text("DELETE FROM capacity_events WHERE id = :id"), {"id": event_id})
        return True if res.rowcount > 0 else False
    except: return False

# --- LAYOUT ---
app = Dash(__name__, external_stylesheets=[dbc.themes.ZEPHYR, "https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css"], suppress_callback_exceptions=True)
app.title = "Capacity Manager"

app.index_string = '''
<!DOCTYPE html>
<html>
    <head>{%metas%}<title>{%title%}</title>{%favicon%}{%css%}
    <style>
        body { background-color: #f8f9fa; font-family: 'Segoe UI', Tahoma, sans-serif; }
        .sidebar { position: fixed; top: 0; left: 0; bottom: 0; width: 16rem; padding: 2rem 1rem; background: #fff; box-shadow: 2px 0 10px rgba(0,0,0,0.05); z-index: 1000; }
        .content { margin-left: 17rem; padding: 2rem; }
        .custom-card { border: none; border-radius: 12px; background: #fff; box-shadow: 0 4px 6px rgba(0,0,0,0.04); overflow: hidden; }
        .kpi-title { font-size: 0.8rem; text-transform: uppercase; letter-spacing: 1px; color: #6c757d; font-weight: 700; }
        .kpi-value { font-size: 2rem; font-weight: 700; color: #2c3e50; }
        .kpi-detail { font-size: 0.8rem; color: #6c757d; display: flex; justify-content: space-between; margin-top: 5px; border-top: 1px solid #eee; padding-top: 5px; }
        .nav-pills .nav-link { font-weight: 500; color: #555; margin-bottom: 5px; transition: 0.2s; }
        .nav-pills .nav-link:hover { background: #f1f3f5; color: #000; }
        .nav-pills .nav-link.active { background: #e7f1ff; color: #0d6efd; font-weight: 700; }
        .table-modern thead th { border-top: none; border-bottom: 2px solid #e9ecef; color: #495057; font-weight: 600; font-size: 0.9rem; }
        .table-modern tbody td { vertical-align: middle; border-color: #f1f3f5; font-size: 0.9rem; }
        .status-dot { height: 8px; width: 8px; border-radius: 50%; display: inline-block; margin-right: 6px; }
        .col-ip { width: 140px; font-family: monospace; color: #0d6efd; }
        
        .badge-manual { background-color: #e7f1ff; color: #0d6efd; padding: 4px 8px; border-radius: 4px; font-weight: 600; font-size: 0.75rem; }
        .badge-csv { background-color: #e6fcf5; color: #0ca678; padding: 4px 8px; border-radius: 4px; font-weight: 600; font-size: 0.75rem; }
        .badge-pending { color: #fcc419; }
        .badge-reconciled { color: #20c997; }
        .val-pos { color: #198754; font-weight: 700; }
        .val-neg { color: #dc3545; font-weight: 700; }
    </style>
    </head>
    <body>{%app_entry%}<footer>{%config%}{%scripts%}{%renderer%}</footer></body>
</html>
'''

sidebar = html.Div([
    html.H3(["Capacity", html.Span(".", style={"color": "#0d6efd"})], className="display-6 fw-bold mb-4 px-2"),
    html.Hr(),
    dbc.Nav([
        dbc.NavLink([html.I(className="bi bi-speedometer2 me-2"), "Dashboard"], id="btn-dash", active=True),
        dbc.NavLink([html.I(className="bi bi-list-check me-2"), "Events"], id="btn-ev"),
        dbc.NavLink([html.I(className="bi bi-server me-2"), "Inventory"], id="btn-inv"),
        dbc.NavLink([html.I(className="bi bi-gear me-2"), "Settings"], id="btn-set"),
    ], vertical=True, pills=True, className="mb-4"),
    html.Div([html.Small("Last Sync:", className="text-muted d-block"), html.Small(id="last-sync", className="fw-bold text-primary")], className="mt-auto pt-4 border-top")
], className="sidebar")

def kpi_card(title, used, total, reserved, avail, pct, color, icon):
    return dbc.Card([
        dbc.CardBody([
            dbc.Row([
                dbc.Col([html.Div(title, className="kpi-title mb-1"), html.Div(used, className="kpi-value")]),
                dbc.Col(html.I(className=f"{icon} fs-2 text-{color} opacity-50"), width="auto")
            ]),
            dbc.Progress(value=min(pct, 100), color=color, style={"height": "6px"}, className="my-2"),
            html.Div([html.Span(f"Total: {total}"), html.Span(f"Rsvd: {reserved}")], className="kpi-detail"),
            html.Div([html.Span(f"Avail: {avail}", className=f"text-{color} fw-bold"), html.Span(f"{pct:.1f}%", className="fw-bold")], className="kpi-detail border-0 pt-1")
        ])
    ], className="custom-card h-100")

def mini_stat_card(title, value, color):
    return dbc.Card(dbc.CardBody([
        html.H6(title, className="text-muted small text-uppercase fw-bold"),
        html.H3(value, className=f"text-{color} mb-0")
    ]), className="custom-card text-center h-100")

# --- VIEWS ---
view_dash = html.Div(id="view-dash", children=[
    dcc.Loading(dbc.Row(id="kpi-row", className="g-4 mb-4")),
    html.Div(id="alert-box"),
    dbc.Row([
        dbc.Col([
            dbc.Row([
                dbc.Col(dbc.Card([dbc.CardHeader("CPU Load", className="bg-white fw-bold border-0"), dbc.CardBody(dcc.Graph(id="cpu-gauge", config={'displayModeBar':False}))], className="custom-card mb-3"), width=12),
                dbc.Col(dbc.Card([dbc.CardHeader("RAM Load", className="bg-white fw-bold border-0"), dbc.CardBody(dcc.Graph(id="ram-gauge", config={'displayModeBar':False}))], className="custom-card mb-3"), width=12),
                dbc.Col(dbc.Card([dbc.CardHeader("Storage Load", className="bg-white fw-bold border-0"), dbc.CardBody(dcc.Graph(id="storage-gauge", config={'displayModeBar':False}))], className="custom-card"), width=12),
            ])
        ], lg=4),
        dbc.Col([
            dbc.Row([
                dbc.Col(dbc.Card([dbc.CardHeader("Top 5 CPU Consumers", className="bg-white fw-bold border-0"), dbc.CardBody(dcc.Graph(id="cpu-top", config={'displayModeBar':False}))], className="custom-card mb-3"), width=12),
                dbc.Col(dbc.Card([dbc.CardHeader("Top 5 RAM Consumers", className="bg-white fw-bold border-0"), dbc.CardBody(dcc.Graph(id="ram-top", config={'displayModeBar':False}))], className="custom-card mb-3"), width=12),
                dbc.Col(dbc.Card([dbc.CardHeader("Top 5 Storage Consumers", className="bg-white fw-bold border-0"), dbc.CardBody(dcc.Graph(id="storage-top", config={'displayModeBar':False}))], className="custom-card"), width=12),
            ])
        ], lg=8),
    ], className="g-4 mb-4")
])

view_events = html.Div(id="view-ev", style={"display": "none"}, children=[
    # 1. Stats Row
    dbc.Row(id="event-stats", className="mb-4 g-4"),
    
    # 2. Actions Panel (Full Width)
    dbc.Row([
        dbc.Col(dbc.Card([
            dbc.CardHeader([html.I(className="bi bi-gear-wide-connected me-2"), "Event Actions"], className="bg-white border-0 fw-bold"),
            dbc.CardBody([
                dbc.Tabs([
                    dbc.Tab(label="Manual Allocation", children=[
                        html.Div([
                            dbc.Row([
                                dbc.Col(dbc.Input(id="server", placeholder="Server Name"), md=3),
                                dbc.Col(dbc.Input(id="cpu", type="number", placeholder="CPU (+/-)"), md=2),
                                dbc.Col(dbc.Input(id="ram", type="number", placeholder="RAM GB (+/-)"), md=2),
                                dbc.Col(dbc.Input(id="stg", type="number", placeholder="Stg GB (+/-)"), md=2),
                                dbc.Col(dbc.Button("Submit", id="submit", color="primary", className="w-100"), md=3)
                            ], className="align-items-center mt-3 g-2"),
                            html.Div(id="man-msg", className="mt-2")
                        ])
                    ]),
                    dbc.Tab(label="CSV Import", children=[
                        dbc.Row([
                            dbc.Col(dcc.Upload(id="csv-up", children=dbc.Button("Select CSV File", color="secondary", outline=True, className="w-100 dashed-border")), md=6),
                            dbc.Col(html.Div(id="csv-msg"), md=6)
                        ], className="align-items-center mt-3")
                    ]),
                    dbc.Tab(label="Delete Event", children=[
                        dbc.Row([
                            dbc.Col(dbc.Input(id="del-id", placeholder="Event ID to Delete", type="number"), md=4),
                            dbc.Col(dbc.Button("Delete", id="btn-del", color="danger"), md=2),
                            dbc.Col(html.Div(id="del-msg", className="small mt-2"), md=6)
                        ], className="align-items-center mt-3")
                    ])
                ], className="nav-fill")
            ])
        ], className="custom-card mb-4"), width=12)
    ]),

    # 3. Event Log Table (Full Width)
    dbc.Row([
        dbc.Col(dbc.Card([
            dbc.CardHeader([
                html.Span("Event Log History", className="fw-bold"),
                html.Div(dcc.DatePickerRange(id="date-filter", start_date=(datetime.now()-timedelta(days=30)).date(), end_date=datetime.now().date(), display_format='YYYY-MM-DD', style={'fontSize':'10px'}), className="float-end")
           
