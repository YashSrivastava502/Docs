# app.py - FULL WORKING & ATTRACTIVE CAPACITY DASHBOARD (January 2026) - UPDATED
# Fixes: missing imports, callback trigger logic, CSV parsing, validation.
# UI: navbar, refresh button, auto-refresh interval, icons, improved cards & alerts.

import base64
import io
from datetime import datetime, timedelta

import pandas as pd
import plotly.express as px
from sqlalchemy import create_engine, text

import logging
from logging.handlers import TimedRotatingFileHandler

from dash import Dash, dcc, html, Input, Output, State, callback, callback_context, no_update
import dash_bootstrap_components as dbc

from config import DB_CONFIG, TOTAL_CAPACITY, RESERVED_PERCENT

# ================= LOGGING (7 day rotate) =================
logger = logging.getLogger("capacity_dashboard")
logger.setLevel(logging.INFO)
handler = TimedRotatingFileHandler("capacity.log", when="midnight", backupCount=7)
formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
handler.setFormatter(formatter)
logger.addHandler(handler)

# ================= DB CONNECTION =================
ENGINE = create_engine(
    f"postgresql+psycopg2://{DB_CONFIG['user']}:{DB_CONFIG['password']}@"
    f"{DB_CONFIG['host']}:{DB_CONFIG['port']}/{DB_CONFIG['dbname']}",
    pool_pre_ping=True
)

# ================= HELPERS =================
def fmt(val, unit):
    val = float(val) if val is not None else 0.0
    if unit == "CPU":
        return f"{int(val):,} cores"
    # For RAM and STORAGE: show TB if >= 1024 GB
    if val >= 1024:
        return f"{val/1024:.2f} TB"
    return f"{val:.2f} GB"

def parse_csv(contents, filename):
    """
    contents: data-url from dcc.Upload
    expected CSV columns: date, server, cpu, ram, storage
    """
    content_type, content_string = contents.split(',')
    decoded = base64.b64decode(content_string)
    try:
        df = pd.read_csv(io.StringIO(decoded.decode('utf-8')))
        # normalize columns to lowercase for flexible header names
        cols_lower = set([c.lower() for c in df.columns])
        required = {'date', 'server', 'cpu', 'ram', 'storage'}
        if not required.issubset(cols_lower):
            raise ValueError("CSV must contain columns: date, server, cpu, ram, storage")
        # rename columns to expected lower-case names
        col_map = {c: c.lower() for c in df.columns}
        df = df.rename(columns=col_map)
        df['date'] = pd.to_datetime(df['date'], errors='coerce')
        df = df.dropna(subset=['date'])
        for col in ['cpu', 'ram', 'storage']:
            df[col] = pd.to_numeric(df[col], errors='coerce').fillna(0)
        df['server'] = df['server'].astype(str)
        return df[['date', 'server', 'cpu', 'ram', 'storage']]
    except Exception as e:
        logger.error(f"CSV parse error: {str(e)}")
        raise ValueError(f"CSV parsing failed: {str(e)}")

# ================= CAPACITY CALCULATION =================
def calculate_capacity():
    try:
        inv = pd.read_sql("""
            SELECT
                COALESCE(SUM(NULLIF(TRIM(servercores), '')::numeric), 0) AS cpu,
                COALESCE(SUM(NULLIF(TRIM(servermemory), '')::numeric)/1024.0, 0) AS ram,
                COALESCE(SUM(NULLIF(TRIM(totaldisk), '')::numeric), 0) AS storage
            FROM inventory
        """, ENGINE)

        base = {
            "CPU": float(inv['cpu'].iloc[0]),
            "RAM": float(inv['ram'].iloc[0]),
            "STORAGE": float(inv['storage'].iloc[0])
        }

        ev = pd.read_sql("""
            SELECT
                COALESCE(SUM(cpu_delta), 0) AS cpu,
                COALESCE(SUM(ram_delta_gb), 0) AS ram,
                COALESCE(SUM(storage_delta_gb), 0) AS storage
            FROM capacity_events
        """, ENGINE)

        used = {
            "CPU": base["CPU"] + float(ev['cpu'].iloc[0]),
            "RAM": base["RAM"] + float(ev['ram'].iloc[0]),
            "STORAGE": base["STORAGE"] + float(ev['storage'].iloc[0])
        }

        result = {}
        for k in used:
            total = TOTAL_CAPACITY.get(k, 0)
            reserved = total * RESERVED_PERCENT
            usable = max(total - reserved, 0)
            used_k = max(used[k], 0)
            pct = (used_k / usable * 100) if usable > 0 else 0
            available = max(usable - used_k, 0)
            result[k] = {
                "used": used_k,
                "total": total,
                "reserved": reserved,
                "usable": usable,
                "available": available,
                "pct": pct
            }
        logger.info(f"Capacity calculated: {result}")
        return result
    except Exception as e:
        logger.error(f"Capacity error: {str(e)}")
        return {
            "CPU": {"used":0,"total":0,"reserved":0,"usable":0,"available":0,"pct":0},
            "RAM": {"used":0,"total":0,"reserved":0,"usable":0,"available":0,"pct":0},
            "STORAGE": {"used":0,"total":0,"reserved":0,"usable":0,"available":0,"pct":0}
        }

# ================= TREND FUNCTION =================
def build_trend(resource):
    try:
        base = pd.read_sql("""
            SELECT
                COALESCE(SUM(NULLIF(TRIM(servercores), '')::numeric), 0) AS cpu,
                COALESCE(SUM(NULLIF(TRIM(servermemory), '')::numeric)/1024.0, 0) AS ram,
                COALESCE(SUM(NULLIF(TRIM(totaldisk), '')::numeric), 0) AS storage
            FROM inventory
        """, ENGINE)

        baseline = float(base[resource.lower()].iloc[0])

        today = datetime.today().date()
        thirty_days_ago = today - timedelta(days=30)

        # We use a CASE to pick the right delta column on the DB side
        df = pd.read_sql(text("""
            SELECT DATE(event_time) AS d,
                   SUM(
                       CASE
                           WHEN :r = 'CPU' THEN COALESCE(cpu_delta, 0)
                           WHEN :r = 'RAM' THEN COALESCE(ram_delta_gb, 0)
                           WHEN :r = 'STORAGE' THEN COALESCE(storage_delta_gb, 0)
                           ELSE 0
                       END
                   ) AS v
            FROM capacity_events
            WHERE event_time >= :start_date
            GROUP BY DATE(event_time)
            ORDER BY d
        """), ENGINE, params={"r": resource, "start_date": thirty_days_ago})

        date_range = pd.date_range(thirty_days_ago, today)
        if df.empty:
            df = pd.DataFrame({"d": date_range, "v": 0})
        else:
            df = df.set_index('d').reindex(date_range).fillna(0).reset_index()
            df.columns = ['d', 'v']
        df['used'] = baseline + df['v'].cumsum()

        fig = px.area(df, x="d", y="used",
                      title=f"{resource} Trend (Last 30 Days)",
                      template="plotly_white",
                      color_discrete_sequence=["#0d6efd"])
        fig.update_layout(height=350, xaxis_title="Date", yaxis_title="Used")
        return fig
    except Exception as e:
        logger.error(f"Trend error: {str(e)}")
        return px.area(title=f"{resource} Trend - No data")

# ================= DASH APP =================
app = Dash(__name__, external_stylesheets=[dbc.themes.CERULEAN, "https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css"])
app.title = "Capacity Management Dashboard"

# Navbar + header with refresh
navbar = dbc.Navbar(
    dbc.Container([
        html.A(
            dbc.Row([
                dbc.Col(html.Img(src="https://raw.githubusercontent.com/plotly/dash-docs/master/images/dash-logo-by-plotly.png", height="30px")),
                dbc.Col(dbc.NavbarBrand("Capacity Dashboard", className="ms-2"))
            ], align="center", className="g-0"),
            href="#"
        ),
        dbc.ButtonGroup([
            dbc.Button(html.Span([html.I(className="bi bi-arrow-clockwise me-2"), "Refresh"]), id="refresh", color="primary"),
        ]),
    ]),
    color="light",
    className="mb-3 shadow-sm",
    sticky="top"
)

app.layout = dbc.Container([
    navbar,
    html.H1("Capacity Management Dashboard", className="text-center my-3 text-primary"),
    dcc.Interval(id="interval", interval=5*60*1000, n_intervals=0),  # auto refresh every 5 minutes

    dbc.Tabs([
        # Dashboard Tab
        dbc.Tab(label="Dashboard", children=[
            html.H4("Current Capacity Overview", className="text-center mt-4 mb-3"),
            dbc.Row(id="kpi-row", className="g-4 mb-5"),
            html.H4("30-Day Usage Trends", className="text-center mb-3"),
            dbc.Row([
                dbc.Col(dcc.Graph(id="cpu-trend"), md=4),
                dbc.Col(dcc.Graph(id="ram-trend"), md=4),
                dbc.Col(dcc.Graph(id="storage-trend"), md=4),
            ]),
            html.Div(id="alerts", className="mt-4")
        ]),

        # Events Tab
        dbc.Tab(label="Events", children=[
            dbc.Row([
                dbc.Col([
                    html.H5("Add New Event", className="text-primary mb-3"),
                    dbc.Input(id="server", placeholder="Server name (required)", className="mb-2"),
                    dbc.Input(id="cpu", type="number", placeholder="CPU Δ (cores)", className="mb-2"),
                    dbc.Input(id="ram", type="number", placeholder="RAM Δ (GB)", className="mb-2"),
                    dbc.Input(id="storage", type="number", placeholder="Storage Δ (GB)", className="mb-3"),
                    dbc.Button("Submit Event", id="submit", color="success", className="w-100 mb-2"),
                    html.Div(id="msg", className="mt-3"),
                    html.Hr(),
                    dcc.Upload(
                        id="csv-upload",
                        children=dbc.Button("Upload CSV (date,server,cpu,ram,storage)", color="info", className="w-100"),
                        multiple=False
                    ),
                    html.Div(id="csv-msg", className="mt-3")
                ], md=4, className="bg-white p-4 rounded shadow"),

                dbc.Col([
                    html.H5("Recent Events (last 10)", className="text-primary mb-3"),
                    html.Div(id="recent-events")
                ], md=8)
            ], className="mt-4")
        ]),

        # Inventory Tab
        dbc.Tab(label="Inventory", children=[
            html.H4("Server Inventory", className="text-center text-primary mt-4 mb-3"),
            html.Div(id="inventory-table")
        ])
    ], className="shadow mb-5")
], fluid=True, className="p-4", style={"background": "linear-gradient(to bottom, #e3f2fd, #f8f9fa)"})

# ================= CALLBACKS =================
@callback(
    [
        Output("kpi-row", "children"),
        Output("alerts", "children"),
        Output("cpu-trend", "figure"),
        Output("ram-trend", "figure"),
        Output("storage-trend", "figure"),
        Output("recent-events", "children"),
        Output("inventory-table", "children"),
        Output("msg", "children"),
        Output("csv-msg", "children")
    ],
    [
        Input("submit", "n_clicks"),
        Input("csv-upload", "contents"),
        Input("interval", "n_intervals"),
        Input("refresh", "n_clicks")
    ],
    [
        State("server", "value"),
        State("cpu", "value"),
        State("ram", "value"),
        State("storage", "value"),
        State("csv-upload", "filename")
    ],
    prevent_initial_call=False
)
def master_callback(submit_n, csv_contents, n_intervals, refresh_n, server, cpu, ram, storage, filename):
    ctx = callback_context
    triggered_prop = ctx.triggered[0]['prop_id'] if ctx.triggered else ""
    triggered_id = triggered_prop.split('.')[0] if triggered_prop else ""

    msg = no_update
    csv_msg = no_update
    refresh_needed = False

    # --- Manual event submit ---
    if triggered_id == "submit" and submit_n:
        if not server:
            msg = dbc.Alert("Server name required", color="danger")
        elif (not cpu and not ram and not storage) and (cpu != 0 and ram != 0 and storage != 0):
            # If all are None/empty - require at least one delta
            msg = dbc.Alert("At least one delta (CPU, RAM or Storage) must be provided", color="danger")
        else:
            try:
                with ENGINE.begin() as conn:
                    conn.execute(text("""
                        INSERT INTO capacity_events
                        (assetuniquename, cpu_delta, ram_delta_gb, storage_delta_gb, source, event_time)
                        VALUES (:s, :c, :r, :st, 'MANUAL', now())
                    """), {"s": server, "c": float(cpu or 0), "r": float(ram or 0), "st": float(storage or 0)})
                msg = dbc.Alert("Event saved", color="success")
                refresh_needed = True
            except Exception as e:
                logger.exception("Failed to insert manual event")
                msg = dbc.Alert(f"Error saving event: {str(e)}", color="danger")

    # --- CSV upload ---
    if triggered_id == "csv-upload" and csv_contents:
        try:
            df = parse_csv(csv_contents, filename)
            with ENGINE.begin() as conn:
                for _, row in df.iterrows():
                    conn.execute(text("""
                        INSERT INTO capacity_events
                        (assetuniquename, cpu_delta, ram_delta_gb, storage_delta_gb, source, event_time)
                        VALUES (:server, :cpu, :ram, :storage, 'CSV', :date)
                    """), {
                        "server": row['server'],
                        "cpu": float(row['cpu']),
                        "ram": float(row['ram']),
                        "storage": float(row['storage']),
                        "date": row['date']
                    })
            csv_msg = dbc.Alert(f"Imported {len(df)} rows", color="success")
            refresh_needed = True
        except Exception as e:
            logger.exception("CSV import failed")
            csv_msg = dbc.Alert(f"CSV error: {str(e)}", color="danger")

    # Refresh if auto interval, refresh button, or we just modified data
    if refresh_needed or triggered_id in ("interval", "refresh") or triggered_id == "":
        cap = calculate_capacity()

        # KPI cards
        kpi_cards = []
        alerts = []
        for k in ["CPU", "RAM", "STORAGE"]:
            d = cap[k]
            # color decision: >100% => danger, >90 => danger (animated), >80 => warning, else success
            if d["pct"] > 100:
                color = "danger"
            elif d["pct"] > 90:
                color = "danger"
            elif d["pct"] > 80:
                color = "warning"
            else:
                color = "success"

            icon = {"CPU": "bi-cpu", "RAM": "bi-memory", "STORAGE": "bi-hdd"}.get(k, "bi-bar-chart")

            card = dbc.Card([
                dbc.CardHeader(html.H5([
                    html.I(className=f"{icon} me-2"),
                    k
                ], className="text-white mb-0"), className=f"bg-{color}"),
                dbc.CardBody([
                    html.H3(fmt(d["used"], k), className="text-center mb-2"),
                    html.Div([
                        html.Small(f"Total: {fmt(d['total'], k)}", className="me-3"),
                        html.Small(f"Reserved: {fmt(d['reserved'], k)}", className="me-3"),
                        html.Small(f"Usable: {fmt(d['usable'], k)}"),
                    ], className="d-flex justify-content-center mb-2 flex-wrap"),
                    dbc.Progress(
                        value=min(d["pct"], 100),
                        color=color,
                        striped=True,
                        animated=d["pct"] > 90,
                        style={"height": "20px"},
                        className="my-2"
                    ),
                    html.P(f"Available: {fmt(d['available'], k)}", className="text-center small mb-0"),
                    html.P(f"Utilization: {d['pct']:.1f}%", className="text-center fw-bold mt-1")
                ])
            ], className="shadow h-100")

            kpi_cards.append(dbc.Col(card, md=4))

            if d["pct"] > 90:
                alerts.append(dbc.Alert(f"High {k} utilization ({d['pct']:.1f}%) — consider action", color="warning", dismissable=True))

        # Trends
        cpu_trend = build_trend("CPU")
        ram_trend = build_trend("RAM")
        storage_trend = build_trend("STORAGE")

        # Recent events
        recent_df = pd.read_sql("""
            SELECT event_time, assetuniquename, cpu_delta, ram_delta_gb, storage_delta_gb
            FROM capacity_events
            ORDER BY event_time DESC LIMIT 10
        """, ENGINE)
        if not recent_df.empty:
            recent_df = recent_df.rename(columns={
                "event_time": "Event Time",
                "assetuniquename": "Server",
                "cpu_delta": "CPU Δ",
                "ram_delta_gb": "RAM Δ (GB)",
                "storage_delta_gb": "Storage Δ (GB)"
            })
            recent_table = dbc.Table.from_dataframe(recent_df, striped=True, hover=True, bordered=True, responsive=True)
        else:
            recent_table = html.P("No recent events", className="text-center text-muted p-4")

        # Inventory table
        inv_df = pd.read_sql("""
            SELECT 
                assetuniquename AS "Server Name",
                assetipaddress AS "IP Address",
                servercores AS "CPU Cores",
                ROUND(COALESCE(NULLIF(TRIM(servermemory), '')::numeric / 1024.0, 0), 2) AS "RAM (GB)",
                totaldisk AS "Storage (GB)",
                assetstatus AS "Status"
            FROM inventory
            ORDER BY assetuniquename
        """, ENGINE).fillna("N/A")
        if not inv_df.empty:
            inv_df["RAM (GB)"] = inv_df["RAM (GB)"].astype(str) + " GB"
            inv_df["Storage (GB)"] = inv_df["Storage (GB)"].astype(str) + " GB"
            inv_table = dbc.Table.from_dataframe(inv_df, striped=True, hover=True, bordered=True, responsive=True)
        else:
            inv_table = html.P("No inventory data", className="text-center text-muted p-4")

        return kpi_cards, alerts, cpu_trend, ram_trend, storage_trend, recent_table, inv_table, no_update, no_update

    # No change - keep current state
    return no_update, no_update, no_update, no_update, no_update, no_update, no_update, no_update, no_update

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8050, debug=False)
