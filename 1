# config.py
DB_URI = "postgresql+psycopg2://postgres:mc6Qld8x0910@10.7.32.181:5432/GlobalInventory"


# main.py
import pandas as pd
from datetime import date
from sqlalchemy import create_engine, text
from dash import Dash, html, dcc, Input, Output
import dash_bootstrap_components as dbc
import plotly.graph_objects as go

# ─── Import config ───────────────────────────────────────
from config import DB_URI

# ─── Database ────────────────────────────────────────────
engine = create_engine(
    DB_URI,
    pool_pre_ping=True,
    pool_size=5,
    max_overflow=10
)

# ─── Data loading functions ──────────────────────────────
def get_latest_snapshot():
    q = """
    SELECT storage_used_gb, ram_used_gb, cpu_used_cores, snapshot_time
    FROM server_capacity_snapshot
    ORDER BY snapshot_time DESC LIMIT 1
    """
    df = pd.read_sql(q, engine)
    if df.empty:
        return pd.Series({
            'storage_used_gb': 0.0,
            'ram_used_gb': 0.0,
            'cpu_used_cores': 0.0,
            'snapshot_time': None
        })
    return df.iloc[0]


def get_totals():
    q = """
    SELECT total_storage_gb, total_ram_gb, total_cpu_cores
    FROM server_capacity_master
    ORDER BY last_updated DESC LIMIT 1
    """
    df = pd.read_sql(q, engine)
    if df.empty:
        raise RuntimeError("No data in server_capacity_master")
    return df.iloc[0]


def load_trend(resource):
    q = """
    SELECT DATE(event_time) AS day, SUM(change_value) AS net
    FROM server_capacity_events
    WHERE resource_type = %s
    GROUP BY day
    ORDER BY day
    """
    df = pd.read_sql(q, engine, params=(resource,))
    if df.empty:
        return pd.DataFrame()
    df['cumulative'] = df['net'].cumsum()
    return df


def load_events(start, end):
    q = text("""
    SELECT event_time, assetuniquename AS server, resource_type,
           action, change_value, source, reason
    FROM server_capacity_events
    WHERE event_time::date BETWEEN :s AND :e
    ORDER BY event_time DESC
    """)
    return pd.read_sql(q, engine, params={"s": start, "e": end})


# ─── Formatters ──────────────────────────────────────────
def fmt_gb(v):
    return f"{v/1024:.2f} TB" if v >= 1024 else f"{int(v):,} GB"


def fmt_cores(v):
    return f"{int(v):,} cores"


def color_for_pct(pct):
    if pct >= 85: return "danger"
    if pct >= 70: return "warning"
    return "success"


def kpi_card(title, used, total, fmt_func, unit=""):
    free = total - used
    pct = used / total * 100 if total > 0 else 0
    col = color_for_pct(pct)

    return dbc.Card(
        dbc.CardBody([
            html.H6(title, className="text-muted"),
            html.H4(fmt_func(used), className=f"text-{col}"),
            html.Hr(),
            html.Small(f"Total: {fmt_func(total)}"),
            html.Br(),
            html.Small(f"Free:  {fmt_func(free)}"),
            html.Br(),
            html.Small(f"{pct:.1f}% used")
        ]),
        className="text-center shadow-sm"
    )


# ─── Dash app ────────────────────────────────────────────
app = Dash(__name__, external_stylesheets=[dbc.themes.LUX])
app.title = "Capacity Dashboard"

app.layout = dbc.Container([
    html.H2("Server Capacity Dashboard", className="text-center my-4"),

    html.Div(id="snapshot-time", className="text-center text-muted mb-4 small"),

    dbc.Row(id="kpis", className="mb-5"),

    dbc.Row([
        dbc.Col(md=7, children=dbc.Card([
            dbc.CardHeader([
                "Trend   ",
                dcc.Dropdown(
                    id="res",
                    options=[
                        {"label": "Storage", "value": "storage"},
                        {"label": "RAM",     "value": "ram"},
                        {"label": "CPU",     "value": "cpu"}
                    ],
                    value="storage",
                    clearable=False,
                    style={"width": "180px", "display": "inline-block"}
                )
            ]),
            dbc.CardBody(dcc.Graph(id="graph", style={"height": "360px"}))
        ])),

        dbc.Col(md=5, children=dbc.Card([
            dbc.CardHeader("Recent Events"),
            dbc.CardBody([
                dcc.DatePickerRange(
                    id="daterange",
                    start_date=date.today(),
                    end_date=date.today()
                ),
                html.Div(id="eventstable", className="mt-3")
            ])
        ]))
    ], className="g-3")   # ← using g-3 instead of gutter=4 (compatible with older dbc)
], fluid=True, className="p-4")


# ─── Callbacks ───────────────────────────────────────────
@app.callback(
    Output("snapshot-time", "children"),
    Input("res", "value")   # just trigger
)
def show_snapshot_time(_):
    s = get_latest_snapshot()
    if s["snapshot_time"] is None:
        return "No snapshot available"
    return f"Snapshot as of: {pd.Timestamp(s['snapshot_time']).strftime('%d %b %Y  %H:%M:%S')}"


@app.callback(
    Output("kpis", "children"),
    Input("snapshot-time", "children")
)
def update_kpis(_):
    s = get_latest_snapshot()
    t = get_totals()
    return dbc.Row([
        dbc.Col(kpi_card("STORAGE", s["storage_used_gb"],   t["total_storage_gb"],   fmt_gb), md=4),
        dbc.Col(kpi_card("RAM",     s["ram_used_gb"],       t["total_ram_gb"],       fmt_gb), md=4),
        dbc.Col(kpi_card("CPU",     s["cpu_used_cores"],    t["total_cpu_cores"],    fmt_cores), md=4),
    ], className="g-3")


@app.callback(
    Output("graph", "figure"),
    Input("res", "value")
)
def update_graph(resource):
    df = load_trend(resource)
    fig = go.Figure()

    if not df.empty:
        fig.add_trace(go.Scatter(
            x=df["day"], y=df["cumulative"],
            mode="lines+markers", line=dict(width=2.5)
        ))

    fig.update_layout(
        height=360, margin=dict(l=40,r=20,t=10,b=50),
        xaxis_title="Date", yaxis_title="Cumulative net change"
    )

    return fig


@app.callback(
    Output("eventstable", "children"),
    Input("daterange", "start_date"),
    Input("daterange", "end_date")
)
def update_table(s, e):
    if not s or not e:
        return html.Div("Select date range", className="text-muted")
    df = load_events(s, e)
    if df.empty:
        return html.Div("No events in this period", className="alert alert-secondary")
    return dbc.Table.from_dataframe(
        df, striped=True, hover=True, size="sm", responsive=True
    )


if __name__ == '__main__':
    app.run(debug=True, host="0.0.0.0", port=8050)
