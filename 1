# mian.py - Capacity Management Dashboard (Full working version)
# - Handles unit consistency (RAM MB/GB), CSV/manual event import, clear instructions, improved UI.
# - Converts user-entered RAM (GB) -> MB on save; normalizes stored event RAM to GB for calculations.
# - Auto-refresh, manual refresh, KPI cards, trends, inventory table with units in headers.

import base64
import io
from datetime import datetime, timedelta

import pandas as pd
import plotly.express as px
from sqlalchemy import create_engine, text

import logging
from logging.handlers import TimedRotatingFileHandler

from dash import Dash, dcc, html, Input, Output, State, callback, callback_context, no_update
import dash_bootstrap_components as dbc

# Expect config.py to provide DB_CONFIG, TOTAL_CAPACITY, RESERVED_PERCENT
# Example config.py:
# DB_CONFIG = {"user":"dbuser","password":"pw","host":"10.7.32.181","port":5432,"dbname":"GlobalInventory"}
# TOTAL_CAPACITY = {"CPU": 1000, "RAM": 102400, "STORAGE": 500000}  # RAM/Storage in GB
# RESERVED_PERCENT = 0.20
from config import DB_CONFIG, TOTAL_CAPACITY, RESERVED_PERCENT

# ================= LOGGING (7 day rotate) =================
logger = logging.getLogger("capacity_dashboard")
logger.setLevel(logging.INFO)
handler = TimedRotatingFileHandler("capacity.log", when="midnight", backupCount=7)
formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
handler.setFormatter(formatter)
logger.addHandler(handler)

# ================= DB CONNECTION =================
ENGINE = create_engine(
    f"postgresql+psycopg2://{DB_CONFIG['user']}:{DB_CONFIG['password']}@"
    f"{DB_CONFIG['host']}:{DB_CONFIG['port']}/{DB_CONFIG['dbname']}",
    pool_pre_ping=True
)

# ================= HELPERS =================
def fmt(val, unit):
    """Format numeric value with unit. CPU is cores (integer), RAM/STORAGE shown in GB or TB."""
    try:
        val = float(val) if val is not None else 0.0
    except Exception:
        val = 0.0
    if unit == "CPU":
        return f"{int(round(val)):,} cores"
    if val >= 1024:
        return f"{val/1024:.2f} TB"
    return f"{val:.2f} GB"

def parse_csv(contents, filename):
    """
    Parse CSV uploaded via dcc.Upload.
    Required columns: date, server, cpu, ram, storage
      - date: pandas-parsable
      - cpu: cores
      - ram: GB (user-friendly) -> convert to MB at insert time
      - storage: GB
    Returns DataFrame with columns: date, server, cpu, ram_gb, storage_gb
    """
    if not contents:
        raise ValueError("No file contents provided")
    content_type, content_string = contents.split(',')
    decoded = base64.b64decode(content_string)
    try:
        df = pd.read_csv(io.StringIO(decoded.decode('utf-8')))
        lc = [c.lower() for c in df.columns]
        required = {'date', 'server', 'cpu', 'ram', 'storage'}
        if not required.issubset(set(lc)):
            raise ValueError("CSV must contain columns: date, server, cpu, ram, storage")
        mapping = {orig: orig.lower() for orig in df.columns}
        df = df.rename(columns=mapping)
        df['date'] = pd.to_datetime(df['date'], errors='coerce')
        df = df.dropna(subset=['date'])
        df['server'] = df['server'].astype(str)
        for col in ['cpu', 'ram', 'storage']:
            df[col] = pd.to_numeric(df[col], errors='coerce').fillna(0)
        df = df[['date', 'server', 'cpu', 'ram', 'storage']].rename(columns={'ram': 'ram_gb', 'storage': 'storage_gb'})
        return df
    except Exception as e:
        logger.exception("Failed parsing CSV")
        raise ValueError(f"CSV parsing failed: {e}")

# ================= UNIT NORMALIZATION HELPERS =================
def normalize_event_ram_to_gb(ev_sum_value, baseline_gb):
    """
    Defensive normalization:
    - If event-sum looks hugely larger than baseline, assume it's in MB and convert to GB.
    - Else assume it's already GB.
    """
    try:
        v = float(ev_sum_value)
    except Exception:
        return 0.0
    if baseline_gb <= 0:
        if abs(v) > 1024 * 10:
            return v / 1024.0
        return v
    if abs(v) > abs(baseline_gb) * 10:
        return v / 1024.0
    return v

# ================= CAPACITY CALCULATION =================
def calculate_capacity():
    try:
        inv = pd.read_sql("""
            SELECT
                COALESCE(SUM(NULLIF(TRIM(servercores), '')::numeric), 0) AS cpu,
                COALESCE(SUM(NULLIF(TRIM(servermemory), '')::numeric)/1024.0, 0) AS ram,
                COALESCE(SUM(NULLIF(TRIM(totaldisk), '')::numeric), 0) AS storage
            FROM inventory
        """, ENGINE)

        base = {
            "CPU": float(inv['cpu'].iloc[0]),
            "RAM": float(inv['ram'].iloc[0]),        # inventory RAM converted to GB (servermemory in MB / 1024)
            "STORAGE": float(inv['storage'].iloc[0])
        }

        ev = pd.read_sql("""
            SELECT
                COALESCE(SUM(cpu_delta), 0) AS cpu,
                COALESCE(SUM(ram_delta_gb), 0) AS ram_sum,
                COALESCE(SUM(storage_delta_gb), 0) AS storage
            FROM capacity_events
        """, ENGINE)

        raw_ram_sum = float(ev['ram_sum'].iloc[0])
        ram_ev_gb = normalize_event_ram_to_gb(raw_ram_sum, base['RAM'])

        used = {
            "CPU": base["CPU"] + float(ev['cpu'].iloc[0]),
            "RAM": base["RAM"] + ram_ev_gb,
            "STORAGE": base["STORAGE"] + float(ev['storage'].iloc[0])
        }

        result = {}
        for k in used:
            total = TOTAL_CAPACITY.get(k, 0)
            reserved = total * RESERVED_PERCENT
            usable = max(total - reserved, 0)
            used_k = max(used[k], 0)
            pct = (used_k / usable * 100) if usable > 0 else 0
            available = max(usable - used_k, 0)
            result[k] = {
                "used": used_k,
                "total": total,
                "reserved": reserved,
                "usable": usable,
                "available": available,
                "pct": pct
            }
        logger.info("Capacity calculated: %s", result)
        return result
    except Exception as e:
        logger.exception("Capacity calculation failed")
        return {
            "CPU": {"used":0,"total":0,"reserved":0,"usable":0,"available":0,"pct":0},
            "RAM": {"used":0,"total":0,"reserved":0,"usable":0,"available":0,"pct":0},
            "STORAGE": {"used":0,"total":0,"reserved":0,"usable":0,"available":0,"pct":0}
        }

# ================= TREND FUNCTION =================
def build_trend(resource):
    """
    Build a human-friendly trend chart (baseline + cumulative events over 30 days).
    Y-axis labeled in cores (CPU) or GB (RAM/STORAGE).
    """
    try:
        base = pd.read_sql("""
            SELECT
                COALESCE(SUM(NULLIF(TRIM(servercores), '')::numeric), 0) AS cpu,
                COALESCE(SUM(NULLIF(TRIM(servermemory), '')::numeric)/1024.0, 0) AS ram,
                COALESCE(SUM(NULLIF(TRIM(totaldisk), '')::numeric), 0) AS storage
            FROM inventory
        """, ENGINE)
        baseline = float(base[resource.lower()].iloc[0])

        today = datetime.today().date()
        thirty_days_ago = today - timedelta(days=30)

        df = pd.read_sql(text("""
            SELECT DATE(event_time) AS d,
                   SUM(
                       CASE
                           WHEN :r = 'CPU' THEN COALESCE(cpu_delta, 0)
                           WHEN :r = 'RAM' THEN COALESCE(ram_delta_gb, 0)
                           WHEN :r = 'STORAGE' THEN COALESCE(storage_delta_gb, 0)
                           ELSE 0
                       END
                   ) AS v
            FROM capacity_events
            WHERE event_time >= :start_date
            GROUP BY DATE(event_time)
            ORDER BY d
        """), ENGINE, params={"r": resource, "start_date": thirty_days_ago})

        date_range = pd.date_range(thirty_days_ago, today)
        if df.empty:
            df = pd.DataFrame({"d": date_range, "v": 0})
        else:
            df = df.set_index('d').reindex(date_range).fillna(0).reset_index()
            df.columns = ['d', 'v']

        # Detect if RAM event values are stored in MB and convert to GB if necessary
        if resource == "RAM":
            if df['v'].abs().max() > (abs(baseline) * 10 if baseline > 0 else 1024 * 10):
                df['v'] = df['v'] / 1024.0

        df['used'] = baseline + df['v'].cumsum()

        y_label = "Used (cores)" if resource == "CPU" else "Used (GB)"
        fig = px.area(df, x="d", y="used",
                      title=f"{resource} Usage - Last 30 Days",
                      template="plotly_white",
                      color_discrete_sequence=["#0d6efd"])
        fig.update_layout(height=360, xaxis_title="Date", yaxis_title=y_label, margin=dict(t=40, b=30))
        return fig
    except Exception as e:
        logger.exception("Trend build failed")
        return px.area(title=f"{resource} Trend - No data")

# ================= DASH APP =================
app = Dash(__name__, external_stylesheets=[dbc.themes.CERULEAN, "https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css"])
app.title = "Capacity Management Dashboard"

# Navbar (no image)
navbar = dbc.Navbar(
    dbc.Container([
        dbc.NavbarBrand("Capacity Dashboard", className="ms-2"),
        dbc.ButtonGroup([
            dbc.Button([html.I(className="bi bi-arrow-clockwise me-2"), "Refresh"], id="refresh", color="primary"),
        ])
    ]),
    color="light",
    className="mb-3 shadow-sm",
    sticky="top"
)

# Instructions helper (for Events tab)
events_instructions = dbc.Card(
    dbc.CardBody([
        html.H6("How to add events (manual)", className="mb-2"),
        html.Ul([
            html.Li("Server: unique server name (required) — match inventory to tie to baseline."),
            html.Li("CPU Δ: number of cores to add (+) or remove (−). Leave blank or 0 if none."),
            html.Li("RAM Δ: enter the change in GB (e.g., 8 or −4). The app converts GB → MB before saving."),
            html.Li("Storage Δ: enter the change in GB (e.g., 100 or −50). Saved in GB."),
            html.Li("At least one of CPU, RAM, or Storage must be a non-zero value."),
        ]),
        html.H6("CSV Upload format", className="mt-3"),
        html.P("CSV must have headers: date,server,cpu,ram,storage (case-insensitive)."),
        html.Pre("Example CSV:\n" "date,server,cpu,ram,storage\n2026-01-10,web-01,2,8,100\n2026-01-11,db-01,0,16,500", style={"whiteSpace": "pre-wrap"})
    ]),
    className="mb-3 shadow-sm"
)

app.layout = dbc.Container([
    navbar,
    html.H1("Capacity Management Dashboard", className="text-center my-3 text-primary"),
    dcc.Interval(id="interval", interval=5*60*1000, n_intervals=0),  # auto refresh every 5 minutes

    dbc.Tabs([
        dbc.Tab(label="Dashboard", children=[
            html.H4("Current Capacity Overview", className="text-center mt-4 mb-3"),
            dbc.Row(id="kpi-row", className="g-4 mb-5"),
            html.H4("30-Day Usage Trends", className="text-center mb-3"),
            dbc.Row([
                dbc.Col(dcc.Graph(id="cpu-trend"), md=4),
                dbc.Col(dcc.Graph(id="ram-trend"), md=4),
                dbc.Col(dcc.Graph(id="storage-trend"), md=4),
            ]),
            html.Div(id="alerts", className="mt-4")
        ]),

        dbc.Tab(label="Events", children=[
            dbc.Row([
                dbc.Col([
                    events_instructions,
                    html.H5("Add New Event", className="text-primary mb-3"),
                    dbc.Input(id="server", placeholder="Server name (required)", className="mb-2"),
                    dbc.Input(id="cpu", type="number", placeholder="CPU Δ (cores)", className="mb-2"),
                    dbc.Input(id="ram", type="number", placeholder="RAM Δ (GB)", className="mb-2"),
                    dbc.Input(id="storage", type="number", placeholder="Storage Δ (GB)", className="mb-3"),
                    dbc.Button("Submit Event", id="submit", color="success", className="w-100 mb-2"),
                    html.Div(id="msg", className="mt-3"),
                    html.Hr(),
                    dcc.Upload(
                        id="csv-upload",
                        children=dbc.Button("Upload CSV (date,server,cpu,ram,storage)", color="info", className="w-100"),
                        multiple=False
                    ),
                    html.Div(id="csv-msg", className="mt-3")
                ], md=5, className="bg-white p-3 rounded shadow"),

                dbc.Col([
                    html.H5("Recent Events (last 10)", className="text-primary mb-3"),
                    html.Div(id="recent-events")
                ], md=7)
            ], className="mt-4")
        ]),

        dbc.Tab(label="Inventory", children=[
            html.H4("Server Inventory", className="text-center text-primary mt-4 mb-3"),
            html.Div(id="inventory-table")
        ])
    ], className="shadow mb-5")
], fluid=True, className="p-4", style={"background": "linear-gradient(to bottom, #e9f2ff, #ffffff)"})

# ================= CALLBACKS =================
@callback(
    [
        Output("kpi-row", "children"),
        Output("alerts", "children"),
        Output("cpu-trend", "figure"),
        Output("ram-trend", "figure"),
        Output("storage-trend", "figure"),
        Output("recent-events", "children"),
        Output("inventory-table", "children"),
        Output("msg", "children"),
        Output("csv-msg", "children")
    ],
    [
        Input("submit", "n_clicks"),
        Input("csv-upload", "contents"),
        Input("interval", "n_intervals"),
        Input("refresh", "n_clicks")
    ],
    [
        State("server", "value"),
        State("cpu", "value"),
        State("ram", "value"),
        State("storage", "value"),
        State("csv-upload", "filename")
    ],
    prevent_initial_call=False
)
def master_callback(submit_n, csv_contents, n_intervals, refresh_n, server, cpu, ram, storage, filename):
    ctx = callback_context
    triggered_prop = ctx.triggered[0]['prop_id'] if ctx.triggered else ""
    triggered_id = triggered_prop.split('.')[0] if triggered_prop else ""

    msg = no_update
    csv_msg = no_update
    refresh_needed = False

    # Manual event submit
    if triggered_id == "submit" and submit_n:
        if not server or str(server).strip() == "":
            msg = dbc.Alert("Server name required", color="danger")
        elif (not cpu or float(cpu) == 0) and (not ram or float(ram) == 0) and (not storage or float(storage) == 0):
            msg = dbc.Alert("At least one non-zero delta (CPU, RAM, or Storage) must be provided", color="danger")
        else:
            try:
                ram_input_mb = 0.0
                if ram is not None:
                    ram_input_mb = float(ram) * 1024.0  # GB -> MB for storage in DB
                with ENGINE.begin() as conn:
                    conn.execute(text("""
                        INSERT INTO capacity_events
                        (assetuniquename, cpu_delta, ram_delta_gb, storage_delta_gb, source, event_time)
                        VALUES (:s, :c, :r, :st, 'MANUAL', now())
                    """), {"s": server, "c": float(cpu or 0), "r": ram_input_mb, "st": float(storage or 0)})
                msg = dbc.Alert("Event saved (RAM converted to MB for storage)", color="success")
                refresh_needed = True
            except Exception as e:
                logger.exception("Failed to insert manual event")
                msg = dbc.Alert(f"Error saving event: {str(e)}", color="danger")

    # CSV upload
    if triggered_id == "csv-upload" and csv_contents:
        try:
            df = parse_csv(csv_contents, filename)
            with ENGINE.begin() as conn:
                for _, row in df.iterrows():
                    ram_input_mb = float(row['ram_gb']) * 1024.0
                    conn.execute(text("""
                        INSERT INTO capacity_events
                        (assetuniquename, cpu_delta, ram_delta_gb, storage_delta_gb, source, event_time)
                        VALUES (:server, :cpu, :ram, :storage, 'CSV', :date)
                    """), {
                        "server": row['server'],
                        "cpu": float(row['cpu']),
                        "ram": ram_input_mb,
                        "storage": float(row['storage']),
                        "date": row['date']
                    })
            csv_msg = dbc.Alert(f"Imported {len(df)} rows (RAM converted GB→MB on save)", color="success")
            refresh_needed = True
        except Exception as e:
            logger.exception("CSV import failed")
            csv_msg = dbc.Alert(f"CSV error: {str(e)}", color="danger")

    # Refresh when needed or on interval/refresh button or initial load
    if refresh_needed or triggered_id in ("interval", "refresh") or triggered_id == "":
        cap = calculate_capacity()

        kpi_cards = []
        alerts = []
        for k in ["CPU", "RAM", "STORAGE"]:
            d = cap[k]
            if d["pct"] > 100:
                color = "danger"
            elif d["pct"] > 90:
                color = "danger"
            elif d["pct"] > 80:
                color = "warning"
            else:
                color = "success"

            icon = {"CPU": "bi-cpu", "RAM": "bi-memory", "STORAGE": "bi-hdd"}.get(k, "bi-bar-chart")

            card = dbc.Card([
                dbc.CardHeader(html.H5([html.I(className=f"{icon} me-2"), k], className="text-white mb-0"), className=f"bg-{color}"),
                dbc.CardBody([
                    html.H3(fmt(d["used"], k), className="text-center mb-2"),
                    html.Div([
                        html.Small(f"Total: {fmt(d['total'], k)}", className="me-3"),
                        html.Small(f"Reserved: {fmt(d['reserved'], k)}", className="me-3"),
                        html.Small(f"Usable: {fmt(d['usable'], k)}"),
                    ], className="d-flex justify-content-center mb-2 flex-wrap"),
                    dbc.Progress(
                        value=min(d["pct"], 100),
                        color=color,
                        striped=True,
                        animated=d["pct"] > 90,
                        style={"height": "20px"},
                        className="my-2"
                    ),
                    html.P(f"Available: {fmt(d['available'], k)}", className="text-center small mb-0"),
                    html.P(f"Utilization: {d['pct']:.1f}%", className="text-center fw-bold mt-1")
                ])
            ], className="shadow h-100")

            kpi_cards.append(dbc.Col(card, md=4))

            if d["pct"] > 90:
                alerts.append(dbc.Alert(f"High {k} utilization ({d['pct']:.1f}%) — consider action", color="warning", dismissable=True))

        cpu_trend = build_trend("CPU")
        ram_trend = build_trend("RAM")
        storage_trend = build_trend("STORAGE")

        recent_df = pd.read_sql("""
            SELECT event_time, assetuniquename, cpu_delta, ram_delta_gb, storage_delta_gb
            FROM capacity_events
            ORDER BY event_time DESC LIMIT 10
        """, ENGINE)
        if not recent_df.empty:
            def present_ram_val(v):
                try:
                    vv = float(v)
                except:
                    return v
                if abs(vv) > 1024 * 2:
                    return f"{vv/1024:.2f} GB"
                return f"{vv:.2f} GB"
            recent_df = recent_df.rename(columns={
                "event_time": "Event Time",
                "assetuniquename": "Server",
                "cpu_delta": "CPU Δ",
                "ram_delta_gb": "RAM Δ",
                "storage_delta_gb": "Storage Δ (GB)"
            })
            recent_df["RAM Δ"] = recent_df["RAM Δ"].apply(present_ram_val)
            recent_table = dbc.Table.from_dataframe(recent_df, striped=True, hover=True, bordered=True, responsive=True)
        else:
            recent_table = html.P("No recent events", className="text-center text-muted p-4")

        inv_df = pd.read_sql("""
            SELECT 
                assetuniquename AS "Server Name",
                assetipaddress AS "IP Address",
                servercores AS "CPU (cores)",
                ROUND(COALESCE(NULLIF(TRIM(servermemory), '')::numeric / 1024.0, 0), 2) AS "RAM (GB)",
                totaldisk AS "Storage (GB)",
                assetstatus AS "Status"
            FROM inventory
            ORDER BY assetuniquename
        """, ENGINE).fillna("N/A")

        if not inv_df.empty:
            inv_table = dbc.Table.from_dataframe(inv_df, striped=True, hover=True, bordered=True, responsive=True)
        else:
            inv_table = html.P("No inventory data", className="text-center text-muted p-4")

        return kpi_cards, alerts, cpu_trend, ram_trend, storage_trend, recent_table, inv_table, no_update, no_update

    return no_update, no_update, no_update, no_update, no_update, no_update, no_update, no_update, no_update

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8050, debug=False)
