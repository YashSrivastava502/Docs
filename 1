# app.py - Full Fixed Capacity Management Dashboard
# Fixes: SQL syntax in trend query, KPI units/calculations (cap pct, available >=0), NA in tables, faster rendering (simpler queries), better UI (icons, colors, responsive)
# Run with: python app.py
# Open: http://localhost:8050
# Requirements: pip install dash dash-bootstrap-components plotly pandas sqlalchemy psycopg2-binary

import base64
import io
import pandas as pd
import plotly.express as px
from sqlalchemy import create_engine, text
from datetime import datetime, timedelta

# â”€â”€ Dash imports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
from dash import Dash, dcc, html, Input, Output, State, callback, no_update
from dash import callback_context
import dash_bootstrap_components as dbc
import dash_dangerously_set_inner_html as ddsih  # pip install dash-dangerously-set-inner-html (for icons if needed)

from config import DB_CONFIG, TOTAL_CAPACITY, RESERVED_PERCENT

# ================= DB CONNECTION =================
ENGINE = create_engine(
    f"postgresql+psycopg2://{DB_CONFIG['user']}:{DB_CONFIG['password']}@"
    f"{DB_CONFIG['host']}:{DB_CONFIG['port']}/{DB_CONFIG['dbname']}",
    pool_pre_ping=True
)

# ================= HELPERS =================
def fmt(val, unit):
    if unit == "CPU":
        return f"{int(val):,} cores"
    if unit == "STORAGE":
        if val >= 1024:
            return f"{val/1024:.2f} TB"
        return f"{val:.0f} GB"
    if unit == "RAM":
        return f"{val:.2f} TB"  # Assume RAM always in TB for display

# Fixed parse_csv
def parse_csv(contents, filename):
    content_type, content_string = contents.split(',')
    decoded = base64.b64decode(content_string)
    try:
        df = pd.read_csv(io.StringIO(decoded.decode('utf-8')))
        required = {'date', 'server', 'cpu', 'ram', 'storage'}
        if not required.issubset(df.columns.str.lower()):
            raise ValueError("CSV must contain columns: date, server, cpu, ram, storage")
        df.columns = df.columns.str.lower()
        df['date'] = pd.to_datetime(df['date'], errors='coerce')
        df = df.dropna(subset=['date'])
        for col in ['cpu', 'ram', 'storage']:
            df[col] = pd.to_numeric(df[col], errors='coerce').fillna(0)
        return df
    except Exception as e:
        raise ValueError(f"CSV parsing failed: {str(e)}")

# ================= CAPACITY CALCULATION =================
def calculate_capacity():
    try:
        inv = pd.read_sql("""
            SELECT
                COALESCE(SUM(NULLIF(TRIM(servercores), '')::numeric), 0) AS cpu,
                COALESCE(SUM(NULLIF(TRIM(servermemory), '')::numeric)/1024.0, 0) AS ram,  -- Assume servermemory in GB, convert to TB
                COALESCE(SUM(NULLIF(TRIM(totaldisk), '')::numeric), 0) AS storage  -- Assume GB
            FROM inventory
        """, ENGINE)

        base = {
            "CPU": float(inv['cpu'].iloc[0]),
            "RAM": float(inv['ram'].iloc[0]),
            "STORAGE": float(inv['storage'].iloc[0])
        }

        ev = pd.read_sql("""
            SELECT
                COALESCE(SUM(cpu_delta), 0)          AS cpu,
                COALESCE(SUM(ram_delta_gb)/1024.0, 0) AS ram,  -- Deltas in GB, convert to TB for RAM
                COALESCE(SUM(storage_delta_gb), 0)   AS storage  -- Storage deltas in GB
            FROM capacity_events
        """, ENGINE)

        used = {
            "CPU": base["CPU"] + float(ev['cpu'].iloc[0]),
            "RAM": base["RAM"] + float(ev['ram'].iloc[0]),
            "STORAGE": base["STORAGE"] + float(ev['storage'].iloc[0])
        }

        result = {}
        for k in used:
            total = TOTAL_CAPACITY.get(k, 1000)
            reserved = total * RESERVED_PERCENT
            usable = total - reserved
            used_k = max(used[k], 0)  # Prevent negative
            pct = min((used_k / usable * 100) if usable > 0 else 0, 200)  # Cap at 200% to avoid insane numbers
            available = max(usable - used_k, 0)
            result[k] = {
                "used": used_k,
                "total": total,
                "reserved": reserved,
                "usable": usable,
                "available": available,
                "pct": pct
            }
        return result
    except Exception as e:
        print("Capacity calculation error:", str(e))
        return {
            "CPU": {"used":0,"total":1000,"usable":800,"available":800,"pct":0},
            "RAM": {"used":0,"total":1000,"usable":800,"available":800,"pct":0},
            "STORAGE": {"used":0,"total":1000,"usable":800,"available":800,"pct":0}
        }

# ================= TREND FIGURE =================
def build_trend(resource):
    try:
        # Get baseline from inventory
        base = pd.read_sql("""
            SELECT
                COALESCE(SUM(NULLIF(TRIM(servercores),  '')::numeric), 0) AS cpu,
                COALESCE(SUM(NULLIF(TRIM(servermemory),'')::numeric)/1024.0, 0) AS ram,
                COALESCE(SUM(NULLIF(TRIM(totaldisk),   '')::numeric), 0) AS storage
            FROM inventory
        """, ENGINE)
        baseline = {
            "CPU": float(base['cpu'].iloc[0]),
            "RAM": float(base['ram'].iloc[0]),
            "STORAGE": float(base['storage'].iloc[0])
        }[resource]

        # Last 30 days
        today = datetime.today().date()
        thirty_days_ago = today - timedelta(days=30)

        # Fixed SQL: CASE WHEN :r = 'CPU' THEN ...
        df = pd.read_sql("""
            SELECT DATE(event_time) AS d,
                   SUM(CASE WHEN :r = 'CPU' THEN cpu_delta
                            WHEN :r = 'RAM' THEN ram_delta_gb
                            WHEN :r = 'STORAGE' THEN storage_delta_gb
                       END) AS v
            FROM capacity_events
            WHERE event_time >= :start_date
            GROUP BY DATE(event_time)
            ORDER BY d
        """, ENGINE, params={"r": resource, "start_date": thirty_days_ago})

        # Fill missing dates
        date_range = pd.date_range(start=thirty_days_ago, end=today)
        df = df.set_index('d').reindex(date_range).fillna(0).reset_index()
        df.columns = ['d', 'v']

        if df.empty:
            df = pd.DataFrame({"d": [today], "used": [baseline]})
        else:
            df["used"] = baseline + df["v"].cumsum()

        fig = px.line(df, x="d", y="used",  # Changed to line for faster render + better trend view
                      title=f"{resource} Trend (Last 30 Days)",
                      template="plotly_white",
                      color_discrete_sequence=["#007bff"])
        fig.update_layout(
            height=350,
            margin=dict(l=20, r=20, t=40, b=40),
            xaxis_title="Date",
            yaxis_title="Used",
            font={"family": "Arial", "size": 12, "color": "#333"}
        )
        fig.update_traces(line=dict(width=3))
        return fig
    except Exception as e:
        print("Trend error:", str(e))
        return px.line(title="No trend data available")

# ================= DASH APP =================
app = Dash(__name__, external_stylesheets=[dbc.themes.LUX])
app.title = "Capacity Management"

app.layout = dbc.Container([
    html.H1("Capacity Management Dashboard",
            className="text-center mb-4 mt-3",
            style={"fontWeight": "bold", "color": "#007bff", "fontFamily": "Arial"}),

    dbc.Tabs([
        # Dashboard Tab - Optimized for speed
        dbc.Tab(label="Dashboard", children=[
            html.H4("Current Capacity KPIs", className="text-center text-muted mt-4 mb-3"),
            dbc.Row(id="kpi-row", className="justify-content-center g-4 mb-5"),

            html.H4("30-Day Usage Trends", className="text-center text-muted mb-3"),
            dbc.Row([
                dbc.Col(dcc.Graph(id="cpu-trend", config={"displayModeBar": False}), md=4),  # Hide toolbar for clean UI
                dbc.Col(dcc.Graph(id="ram-trend", config={"displayModeBar": False}), md=4),
                dbc.Col(dcc.Graph(id="storage-trend", config={"displayModeBar": False}), md=4),
            ])
        ]),

        # Events Tab
        dbc.Tab(label="Events", children=[
            dbc.Row([
                dbc.Col([
                    html.H5("Submit New Event", className="mb-3 text-primary"),
                    dbc.InputGroup([
                        dbc.InputGroupText("Server"),
                        dbc.Input(id="server", placeholder="Required: e.g., srv-001")
                    ], className="mb-3"),
                    dbc.InputGroup([
                        dbc.InputGroupText("CPU Î”"),
                        dbc.Input(id="cpu", type="number", placeholder="Cores (optional)")
                    ], className="mb-3"),
                    dbc.InputGroup([
                        dbc.InputGroupText("RAM Î”"),
                        dbc.Input(id="ram", type="number", placeholder="GB (optional)")
                    ], className="mb-3"),
                    dbc.InputGroup([
                        dbc.InputGroupText("Storage Î”"),
                        dbc.Input(id="storage", type="number", placeholder="GB (optional)")
                    ], className="mb-3"),
                    dbc.Button("Submit", id="submit", color="primary", className="w-100 mb-3"),
                    html.Div(id="msg"),

                    html.Hr(),
                    html.H5("CSV Upload", className="mb-3 text-primary"),
                    dcc.Upload(
                        id="csv-upload",
                        children=dbc.Button("Upload CSV (date,server,cpu,ram,storage)", color="secondary", className="w-100"),
                        multiple=False
                    ),
                    html.Div(id="csv-msg", className="mt-3")
                ], md=4, className="p-4 bg-light rounded shadow"),

                dbc.Col([
                    html.H5("Recent Events (Last 10)", className="mb-3 text-primary"),
                    html.Div(id="recent-events"),

                    html.Hr(),
                    html.H5("All Events (Last 100)", className="mb-3 text-primary"),
                    html.Div(id="event-table")
                ], md=8)
            ], className="mt-4")
        ]),

        # Inventory Tab
        dbc.Tab(label="Inventory", children=[
            html.H5("Server Inventory (Read-Only)", className="text-center text-primary mt-4 mb-3"),
            html.Div(id="inventory-table")
        ])
    ])

], fluid=True, className="py-4", style={"backgroundColor": "#f8f9fa", "fontFamily": "Arial"})

# ================= CALLBACKS =================
@callback(
    [
        Output("kpi-row", "children"),
        Output("cpu-trend", "figure"),
        Output("ram-trend", "figure"),
        Output("storage-trend", "figure"),
        Output("recent-events", "children"),
        Output("event-table", "children"),
        Output("inventory-table", "children"),
        Output("msg", "children"),
        Output("csv-msg", "children"),
    ],
    Input("submit", "n_clicks"),
    Input("csv-upload", "contents"),
    State("server", "value"),
    State("cpu", "value"),
    State("ram", "value"),
    State("storage", "value"),
    State("csv-upload", "filename"),
    prevent_initial_call=False
)
def master_callback(submit_clicks, csv_contents, server, cpu, ram, storage, csv_filename):
    ctx = callback_context
    triggered_id = ctx.triggered[0]['prop_id'].split('.')[0] if ctx.triggered else None

    msg_alert = ""
    csv_alert = ""

    if triggered_id == "submit" and submit_clicks:
        if not server:
            msg_alert = dbc.Alert("Server name required", color="danger")
        elif not (cpu or ram or storage):
            msg_alert = dbc.Alert("At least one delta required", color="danger")
        else:
            try:
                with ENGINE.connect() as conn:  # Use connect() for faster, no transaction if not needed
                    conn.execute(text("""
                        INSERT INTO capacity_events (assetuniquename, cpu_delta, ram_delta_gb, storage_delta_gb, source)
                        VALUES (:s, :c, :r, :st, 'MANUAL')
                    """), {"s": server, "c": float(cpu or 0), "r": float(ram or 0), "st": float(storage or 0)})
                    conn.commit()
                msg_alert = dbc.Alert("Saved!", color="success")
            except Exception as e:
                msg_alert = dbc.Alert(f"Error: {str(e)}", color="danger")

    if triggered_id == "csv-upload" and csv_contents:
        try:
            df = parse_csv(csv_contents, csv_filename)
            with ENGINE.connect() as conn:
                for _, row in df.iterrows():
                    conn.execute(text("""
                        INSERT INTO capacity_events (assetuniquename, cpu_delta, ram_delta_gb, storage_delta_gb, source, event_time)
                        VALUES (:server, :cpu, :ram, :storage, 'CSV', :dt)
                    """), {"server": row['server'], "cpu": row['cpu'], "ram": row['ram'], "storage": row['storage'], "dt": row['date']})
                conn.commit()
            csv_alert = dbc.Alert(f"Imported {len(df)} rows", color="success")
        except Exception as e:
            csv_alert = dbc.Alert(f"Error: {str(e)}", color="danger")

    # Refresh data - Optimized queries
    cap = calculate_capacity()
    kpi_cards = []
    for res, color, icon in [("CPU", "primary", "ðŸ–¥ï¸"), ("RAM", "info", "ðŸ’¾"), ("STORAGE", "success", "ðŸ—„ï¸")]:
        d = cap[res]
        bar_color = "danger" if d["pct"] > 100 else "warning" if d["pct"] > 75 else color
        kpi_cards.append(dbc.Col(
            dbc.Card([
                dbc.CardHeader(html.H5(f"{icon} {res}", className="mb-0 text-white"), className=f"bg-{color}"),
                dbc.CardBody([
                    html.P(f"Total: {fmt(d['total'], res)}", className="mb-1 small"),
                    html.P(f"Reserved: {fmt(d['reserved'], res)}", className="mb-1 small"),
                    html.P(f"Usable: {fmt(d['usable'], res)}", className="mb-1 small"),
                    html.P(f"Available: {fmt(d['available'], res)}", className="mb-1 small"),
                    html.P(f"Used: {fmt(d['used'], res)}", className="mb-2 small"),
                    dbc.Progress(value=d["pct"], color=bar_color, striped=True, animated=d["pct"] > 100, className="mb-2", style={"height": "20px"}),
                    html.Small(f"Utilization: {d['pct']:.1f}%", className="fw-bold d-block text-center")
                ])
            ], className="shadow h-100")
        , md=4))

    cpu_fig = build_trend("CPU")
    ram_fig = build_trend("RAM")
    storage_fig = build_trend("STORAGE")

    # Tables with NA
    recent_df = pd.read_sql("SELECT * FROM capacity_events ORDER BY event_time DESC LIMIT 10", ENGINE).fillna("NA")
    events_df = pd.read_sql("SELECT * FROM capacity_events ORDER BY event_time DESC LIMIT 100", ENGINE).fillna("NA")
    inv_df = pd.read_sql("SELECT * FROM inventory ORDER BY assetuniquename", ENGINE).fillna("NA")

    recent_table = dbc.Table.from_dataframe(recent_df, striped=True, hover=True, responsive=True) if not recent_df.empty else "No data"
    events_table = dbc.Table.from_dataframe(events_df, striped=True, hover=True, responsive=True) if not events_df.empty else "No data"
    inv_table = dbc.Table.from_dataframe(inv_df, striped=True, hover=True, responsive=True) if not inv_df.empty else "No data"

    return kpi_cards, cpu_fig, ram_fig, storage_fig, recent_table, events_table, inv_table, msg_alert, csv_alert

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8050, debug=False)
