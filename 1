import sqlite3
from datetime import datetime

import altair as alt
import pandas as pd
import streamlit as st

DB_PATH = "metrics.db"  # path to your SQLite DB file


# =============== DB HELPERS ===============

def query_db(sql: str, params=()):
    """Run a query and return a pandas DataFrame."""
    with sqlite3.connect(DB_PATH) as conn:
        df = pd.read_sql_query(sql, conn, params=params)
    return df


def get_os_types():
    df = query_db(
        "SELECT DISTINCT os_type FROM server_daily_metrics ORDER BY os_type;"
    )
    return df["os_type"].tolist()


def get_dates():
    # Use substr(metric_date,1,10) in case metric_date has time as well
    df = query_db(
        """
        SELECT DISTINCT substr(metric_date, 1, 10) AS metric_date
        FROM server_daily_metrics
        ORDER BY metric_date DESC;
        """
    )
    return df["metric_date"].tolist()


def load_data(os_type: str, metric_date: str):
    # Compare only date part (first 10 chars) for safety
    sql = """
        SELECT
            metric_date,
            instance,
            os_type,
            max_cpu,
            avg_cpu,
            max_mem,
            avg_mem,
            disk_util
        FROM server_daily_metrics
        WHERE os_type = ?
          AND substr(metric_date, 1, 10) = ?
        ORDER BY instance;
    """
    df = query_db(sql, (os_type, metric_date))

    # Ensure numeric types
    for col in ["max_cpu", "avg_cpu", "max_mem", "avg_mem", "disk_util"]:
        if col in df.columns:
            df[col] = pd.to_numeric(df[col], errors="coerce")

    return df


# =============== STREAMLIT APP ===============

def main():
    st.set_page_config(
        page_title="Server Performance Dashboard",
        layout="wide",
    )

    st.title("ðŸ“Š Server Performance Dashboard")
    st.caption("Data from metrics.db (Windows & Linux daily performance metrics)")

    # ---------- Sidebar Filters ----------
    st.sidebar.header("Filters")

    os_types = get_os_types()
    if not os_types:
        st.error("âŒ No OS types found in database. Check metrics.db / ETL.")
        return

    selected_os = st.sidebar.selectbox("OS Type", os_types, index=0)

    dates = get_dates()
    if not dates:
        st.error("âŒ No dates found in database.")
        return

    selected_date = st.sidebar.selectbox("Metric Date", dates, index=0)

    st.sidebar.markdown("---")
    st.sidebar.subheader("Table Filters")

    instance_filter = st.sidebar.text_input(
        "Instance contains (optional)",
        value="",
        help="Filter rows where instance name or IP contains this text",
    )

    # Sliders for ranges (optional)
    st.sidebar.markdown("**CPU / Memory / Disk ranges**")

    cpu_min, cpu_max = st.sidebar.slider(
        "Max CPU (%) range", 0.0, 100.0, (0.0, 100.0), step=1.0
    )
    mem_min, mem_max = st.sidebar.slider(
        "Max Memory (%) range", 0.0, 100.0, (0.0, 100.0), step=1.0
    )
    disk_min, disk_max = st.sidebar.slider(
        "Disk Util (%) range", 0.0, 100.0, (0.0, 100.0), step=1.0
    )

    # ---------- Load data ----------
    df = load_data(selected_os, selected_date)

    if df.empty:
        st.warning(f"âš  No rows found for OS = {selected_os}, Date = {selected_date}")
        return

    # Apply table filters
    if instance_filter.strip():
        df = df[df["instance"].str.contains(instance_filter.strip(), case=False, na=False)]

    # Range filters (only if column not all NaN)
    if not df["max_cpu"].isna().all():
        df = df[(df["max_cpu"] >= cpu_min) & (df["max_cpu"] <= cpu_max)]

    if not df["max_mem"].isna().all():
        df = df[(df["max_mem"] >= mem_min) & (df["max_mem"] <= mem_max)]

    if "disk_util" in df.columns and not df["disk_util"].isna().all():
        df = df[(df["disk_util"] >= disk_min) & (df["disk_util"] <= disk_max)]

    if df.empty:
        st.warning("âš  No rows left after applying filters. Try relaxing the filters.")
        return

    st.markdown(
        f"### ðŸ”Ž View for **OS = `{selected_os}`**, **Date = `{selected_date}`**"
    )

    # ---------- KPI Cards ----------
    col1, col2, col3, col4 = st.columns(4)

    with col1:
        st.metric(
            "Avg Max CPU (%)",
            f"{df['max_cpu'].mean():.2f}" if not df["max_cpu"].isna().all() else "N/A",
        )
    with col2:
        st.metric(
            "Avg Max Memory (%)",
            f"{df['max_mem'].mean():.2f}" if not df["max_mem"].isna().all() else "N/A",
        )
    with col3:
        if "disk_util" in df.columns and not df["disk_util"].isna().all():
            st.metric(
                "Avg Disk Util (%)",
                f"{df['disk_util'].mean():.2f}",
            )
        else:
            st.metric("Avg Disk Util (%)", "N/A")
    with col4:
        st.metric("Total Instances", len(df))

    st.markdown("---")

    # ---------- Charts ----------
    st.subheader("ðŸ“ˆ Top Resource Usage (Selected Date)")

    left, right = st.columns(2)

    # Top 10 by Max CPU
    with left:
        st.markdown("**Top 10 Instances by Max CPU (%)**")
        top_cpu = df.sort_values("max_cpu", ascending=False).head(10).copy()
        if not top_cpu.empty and not top_cpu["max_cpu"].isna().all():
            cpu_chart = (
                alt.Chart(top_cpu)
                .mark_bar()
                .encode(
                    x=alt.X("max_cpu:Q", title="Max CPU (%)"),
                    y=alt.Y("instance:N", sort="-x", title="Instance"),
                    tooltip=["instance", "max_cpu", "avg_cpu"],
                )
                .properties(height=350)
            )
            st.altair_chart(cpu_chart, use_container_width=True)
        else:
            st.info("No CPU data available for chart.")

    # Top 10 by Max Memory
    with right:
        st.markdown("**Top 10 Instances by Max Memory (%)**")
        top_mem = df.sort_values("max_mem", ascending=False).head(10).copy()
        if not top_mem.empty and not top_mem["max_mem"].isna().all():
            mem_chart = (
                alt.Chart(top_mem)
                .mark_bar()
                .encode(
                    x=alt.X("max_mem:Q", title="Max Memory (%)"),
                    y=alt.Y("instance:N", sort="-x", title="Instance"),
                    tooltip=["instance", "max_mem", "avg_mem"],
                )
                .properties(height=350)
            )
            st.altair_chart(mem_chart, use_container_width=True)
        else:
            st.info("No Memory data available for chart.")

    st.markdown("---")

    # ---------- Detailed Table ----------
    st.subheader("ðŸ“‹ Detailed Metrics Table (Filtered)")

    display_df = df.rename(
        columns={
            "metric_date": "Metric Date",
            "instance": "Instance",
            "os_type": "OS",
            "max_cpu": "Max CPU (%)",
            "avg_cpu": "Avg CPU (%)",
            "max_mem": "Max Memory (%)",
            "avg_mem": "Avg Memory (%)",
            "disk_util": "Disk Util (%)",
        }
    )

    st.dataframe(
        display_df,
        use_container_width=True,
        height=450,
    )

    # Download filtered table
    csv_export = display_df.to_csv(index=False).encode("utf-8")
    st.download_button(
        label="â¬‡ï¸ Download this table as CSV",
        data=csv_export,
        file_name=f"metrics_{selected_os}_{selected_date}.csv",
        mime="text/csv",
    )


if __name__ == "__main__":
    main()
