import psycopg2
import pandas as pd
import os
import time
from threading import Thread
from dash import Dash, html, dcc, Input, Output, State
import dash_bootstrap_components as dbc
import plotly.graph_objs as go

# ================= CONFIG =================
DB = dict(
    host="10.7.32.181",
    dbname="GlobalInventory",
    user="postgres",
    password="mc6Qld8x0910"
)

RESERVED_PERCENT = 30
ALERT_THRESHOLD = 75

# CSV AUTO PICKUP
CSV_AUTO_ENABLED = True
CSV_WATCH_DIR = "csv_inbox"
CSV_ARCHIVE_DIR = "csv_archive"
CSV_POLL_SECONDS = 60

os.makedirs(CSV_WATCH_DIR, exist_ok=True)
os.makedirs(CSV_ARCHIVE_DIR, exist_ok=True)

# ================= DB =================
def get_conn():
    return psycopg2.connect(**DB)

# ================= SNAPSHOT =================
def calculate_snapshot(asset):
    with get_conn() as conn:
        q = """
        SELECT
            COALESCE(NULLIF(i.servercores,''),'0')::NUMERIC,
            COALESCE(NULLIF(i.servermemory,''),'0')::NUMERIC / 1024,
            COALESCE(NULLIF(i.totaldisk,''),'0')::NUMERIC,
            m.total_cpu, m.total_ram_gb, m.total_storage_gb,
            COALESCE(SUM(CASE WHEN e.resource_type='cpu' THEN e.change_value END),0),
            COALESCE(SUM(CASE WHEN e.resource_type='ram' THEN e.change_value END),0),
            COALESCE(SUM(CASE WHEN e.resource_type='storage' THEN e.change_value END),0)
        FROM inventory i
        JOIN server_capacity_master m ON m.assetuniquename=i.assetuniquename
        LEFT JOIN server_capacity_events e ON e.assetuniquename=i.assetuniquename
        WHERE i.assetuniquename=%s
        GROUP BY i.servercores,i.servermemory,i.totaldisk,
                 m.total_cpu,m.total_ram_gb,m.total_storage_gb
        """
        cur = conn.cursor()
        cur.execute(q, (asset,))
        r = cur.fetchone()

    return {
        "cpu_used": float(r[0] + r[6]),
        "ram_used": float(r[1] + r[7]),
        "storage_used": float(r[2] + r[8]),
        "usable_cpu": float(r[3] * 0.7),
        "usable_ram": float(r[4] * 0.7),
        "usable_storage": float(r[5] * 0.7)
    }

# ================= TREND =================
def get_trend(asset, resource):
    with get_conn() as conn:
        return pd.read_sql("""
            SELECT DATE(created_at) d,
                   SUM(change_value) v
            FROM server_capacity_events
            WHERE assetuniquename=%s AND resource_type=%s
            GROUP BY DATE(created_at)
            ORDER BY d
        """, conn, params=(asset, resource))

# ================= EVENTS =================
def get_recent_events(asset):
    with get_conn() as conn:
        return pd.read_sql("""
            SELECT assetuniquename, resource_type, change_type,
                   change_value, source, created_at
            FROM server_capacity_events
            WHERE assetuniquename=%s
            ORDER BY created_at DESC
            LIMIT 10
        """, conn, params=(asset,))

# ================= CSV AUTO PICKUP =================
def csv_watcher():
    while True:
        if CSV_AUTO_ENABLED:
            for f in os.listdir(CSV_WATCH_DIR):
                if f.endswith(".csv"):
                    path = os.path.join(CSV_WATCH_DIR, f)
                    df = pd.read_csv(path)

                    with get_conn() as conn:
                        cur = conn.cursor()
                        for _, r in df.iterrows():
                            val = abs(r["change_value"])
                            if r["change_type"] == "deallocate":
                                val = -val
                            cur.execute("""
                                INSERT INTO server_capacity_events
                                (assetuniquename,resource_type,change_type,change_value,reason,source)
                                VALUES (%s,%s,%s,%s,%s,'CSV_AUTO')
                            """, (
                                r["assetuniquename"],
                                r["resource_type"],
                                r["change_type"],
                                val,
                                r.get("reason","")
                            ))
                        conn.commit()

                    os.rename(
                        path,
                        os.path.join(CSV_ARCHIVE_DIR, f)
                    )
        time.sleep(CSV_POLL_SECONDS)

Thread(target=csv_watcher, daemon=True).start()

# ================= DASH =================
app = Dash(__name__, external_stylesheets=[dbc.themes.FLATLY])

def kpi(title, value, color):
    return dbc.Card(
        dbc.CardBody([html.H6(title), html.H2(value)]),
        color=color, className="shadow-sm"
    )

def servers():
    with get_conn() as conn:
        return pd.read_sql(
            "SELECT assetuniquename FROM server_capacity_master",
            conn
        )["assetuniquename"].tolist()

app.layout = dbc.Container(fluid=True, children=[

    html.H3("Server Capacity Dashboard", className="my-3"),

    dcc.Dropdown(
        id="server",
        options=[{"label":s,"value":s} for s in servers()],
        placeholder="Select Server"
    ),

    html.Br(),

    dbc.Row([
        dbc.Col(id="kpi-total", md=3),
        dbc.Col(id="kpi-reserved", md=3),
        dbc.Col(id="kpi-usable", md=3),
        dbc.Col(id="kpi-used", md=3),
    ]),

    html.Hr(),

    dbc.Row([
        dbc.Col(
            dbc.Card([
                dbc.CardHeader("Allocate / Deallocate"),
                dbc.CardBody([
                    dcc.RadioItems(
                        id="action",
                        options=[
                            {"label":"Allocate","value":"allocate"},
                            {"label":"Deallocate","value":"deallocate"}
                        ],
                        value="allocate"
                    ),
                    dbc.Input(id="storage", type="number", placeholder="Storage (GB)"),
                    dbc.Input(id="ram", type="number", placeholder="RAM (GB)", className="mt-2"),
                    dbc.Input(id="cpu", type="number", placeholder="CPU", className="mt-2"),
                    dbc.Button("Submit", id="submit", color="primary", className="mt-3"),
                    html.Div(id="status")
                ])
            ]),
            md=3
        ),
        dbc.Col(
            dbc.Card([
                dbc.CardHeader("Storage Usage Trend"),
                dbc.CardBody(dcc.Graph(id="trend"))
            ]),
            md=9
        )
    ]),

    html.Hr(),

    dbc.Card([
        dbc.CardHeader("Recent Events"),
        dbc.CardBody(html.Div(id="events"))
    ])
])

# ================= CALLBACKS =================
@app.callback(
    Output("kpi-total","children"),
    Output("kpi-reserved","children"),
    Output("kpi-usable","children"),
    Output("kpi-used","children"),
    Output("trend","figure"),
    Output("events","children"),
    Input("server","value")
)
def refresh(server):
    if not server:
        return "","","","",go.Figure(),""

    snap = calculate_snapshot(server)
    total = snap["usable_storage"] / 0.7
    used = snap["storage_used"]
    pct = (used / snap["usable_storage"]) * 100

    color = "danger" if pct >= ALERT_THRESHOLD else "success"

    df = get_trend(server, "storage")
    fig = go.Figure()
    fig.add_trace(go.Scatter(x=df["d"], y=df["v"].cumsum(), fill="tozeroy"))
    fig.update_layout(height=300, margin=dict(l=20,r=20,t=20,b=20))

    events = get_recent_events(server)

    table = dbc.Table.from_dataframe(
        events,
        striped=True,
        bordered=False,
        hover=True
    )

    return (
        kpi("Total Capacity", f"{total:.1f} GB", "primary"),
        kpi("Reserved (30%)", f"{total*0.3:.1f} GB", "warning"),
        kpi("Usable Capacity", f"{snap['usable_storage']:.1f} GB", "success"),
        kpi(f"Used ({pct:.1f}%)", f"{used:.1f} GB", color),
        fig,
        table
    )

@app.callback(
    Output("status","children"),
    Input("submit","n_clicks"),
    State("server","value"),
    State("action","value"),
    State("storage","value"),
    State("ram","value"),
    State("cpu","value")
)
def submit(n, server, action, s, r, c):
    if not n or not server:
        return ""

    with get_conn() as conn:
        cur = conn.cursor()
        for res,val in {"storage":s,"ram":r,"cpu":c}.items():
            if val:
                v = abs(val)
                if action=="deallocate":
                    v = -v
                cur.execute("""
                    INSERT INTO server_capacity_events
                    (assetuniquename,resource_type,change_type,change_value,source)
                    VALUES (%s,%s,%s,%s,'DASH')
                """,(server,res,action,v))
        conn.commit()

    return "âœ… Updated"

# ================= RUN =================
if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8050, debug=True)
