# app.py - Full Capacity Management Dashboard Code
# Run with: python app.py
# Open: http://localhost:8050
# Requirements: pip install dash dash-bootstrap-components plotly pandas sqlalchemy psycopg2-binary

import base64
import io
import pandas as pd
import plotly.express as px
from sqlalchemy import create_engine, text
from datetime import datetime, timedelta

# ── Dash imports ────────────────────────────────────────────────
from dash import Dash, dcc, html, Input, Output, State, callback, no_update
from dash import callback_context  # Fixed the NameError
import dash_bootstrap_components as dbc

from config import DB_CONFIG, TOTAL_CAPACITY, RESERVED_PERCENT

# ================= DB CONNECTION =================
ENGINE = create_engine(
    f"postgresql+psycopg2://{DB_CONFIG['user']}:{DB_CONFIG['password']}@"
    f"{DB_CONFIG['host']}:{DB_CONFIG['port']}/{DB_CONFIG['dbname']}",
    pool_pre_ping=True
)

# ================= HELPERS =================
def fmt(val, unit):
    if unit == "CPU":
        return f"{int(val):,} cores"
    if val >= 1024:
        return f"{val/1024:.2f} TB"
    return f"{val:.0f} GB"

def parse_csv(contents, filename):
    content_type, content_string = contents.split(',')
    decoded = base64.b64decode(content_string)
    try:
        df = pd.read_csv(io.StringIO(decoded.decode('utf-8')))
        required = {'date', 'server', 'cpu', 'ram', 'storage'}
        if not required.issubset(df.columns.str.lower()):
            raise ValueError("CSV must contain columns: date, server, cpu, ram, storage")
        df.columns = df.columns.str.lower()
        df['date'] = pd.to_datetime(df['date'], errors='coerce')
        df = df.dropna(subset=['date'])
        for col in ['cpu', 'ram', 'storage']:
            df[col] = pd.to_numeric(df[col], errors='coerce').fillna(0)
        return df
    except Exception as e:
        raise ValueError(f"CSV parsing failed: {str(e)}")

# ================= CAPACITY CALCULATION =================
def calculate_capacity():
    try:
        inv = pd.read_sql("""
            SELECT
                COALESCE(SUM(NULLIF(TRIM(servercores),  '')::numeric), 0) AS cpu,
                COALESCE(SUM(NULLIF(TRIM(servermemory),'')::numeric)/1024.0, 0) AS ram,
                COALESCE(SUM(NULLIF(TRIM(totaldisk),   '')::numeric), 0) AS storage
            FROM inventory
        """, ENGINE)

        base = {
            "CPU": float(inv['cpu'].iloc[0]),
            "RAM": float(inv['ram'].iloc[0]),
            "STORAGE": float(inv['storage'].iloc[0])
        }

        ev = pd.read_sql("""
            SELECT
                COALESCE(SUM(cpu_delta), 0)          AS cpu,
                COALESCE(SUM(ram_delta_gb), 0)       AS ram,
                COALESCE(SUM(storage_delta_gb), 0)   AS storage
            FROM capacity_events
        """, ENGINE)

        used = {
            "CPU": base["CPU"] + float(ev['cpu'].iloc[0]),
            "RAM": base["RAM"] + float(ev['ram'].iloc[0]),
            "STORAGE": base["STORAGE"] + float(ev['storage'].iloc[0])
        }

        result = {}
        for k in used:
            total = TOTAL_CAPACITY.get(k, 1000)
            reserved = total * RESERVED_PERCENT
            usable = total - reserved
            pct = (used[k] / usable * 100) if usable > 0 else 0
            available = usable - used[k] if usable > used[k] else 0
            result[k] = {
                "used": used[k],
                "total": total,
                "reserved": reserved,
                "usable": usable,
                "available": available,
                "pct": pct
            }
        return result
    except Exception as e:
        print("Capacity calculation error:", str(e))
        return {
            "CPU": {"used":0,"total":1000,"usable":800,"available":800,"pct":0},
            "RAM": {"used":0,"total":1000,"usable":800,"available":800,"pct":0},
            "STORAGE": {"used":0,"total":1000,"usable":800,"available":800,"pct":0}
        }

# ================= TREND FIGURE =================
def build_trend(resource):
    try:
        # Get baseline from inventory
        base = pd.read_sql("""
            SELECT
                COALESCE(SUM(NULLIF(TRIM(servercores),  '')::numeric), 0) AS cpu,
                COALESCE(SUM(NULLIF(TRIM(servermemory),'')::numeric)/1024.0, 0) AS ram,
                COALESCE(SUM(NULLIF(TRIM(totaldisk),   '')::numeric), 0) AS storage
            FROM inventory
        """, ENGINE)
        baseline = {
            "CPU": float(base['cpu'].iloc[0]),
            "RAM": float(base['ram'].iloc[0]),
            "STORAGE": float(base['storage'].iloc[0])
        }[resource]

        # Last 30 days
        today = datetime.today().date()
        thirty_days_ago = today - timedelta(days=30)

        df = pd.read_sql("""
            SELECT DATE(event_time) AS d,
                   SUM(CASE :r
                       WHEN 'CPU'     THEN cpu_delta
                       WHEN 'RAM'     THEN ram_delta_gb
                       WHEN 'STORAGE' THEN storage_delta_gb
                   END) AS v
            FROM capacity_events
            WHERE event_time >= :start_date
            GROUP BY DATE(event_time)
            ORDER BY d
        """, ENGINE, params={"r": resource, "start_date": thirty_days_ago})

        # Fill missing dates with 0 delta
        date_range = pd.date_range(start=thirty_days_ago, end=today)
        df = df.set_index('d').reindex(date_range).fillna(0).reset_index()
        df.columns = ['d', 'v']  # Rename after reindex

        if df.empty:
            df = pd.DataFrame({"d": [today], "used": [baseline]})
        else:
            df["used"] = baseline + df["v"].cumsum()

        fig = px.area(df, x="d", y="used",
                      title=f"{resource} Usage Trend (Last 30 Days)",
                      template="plotly_dark",
                      color_discrete_sequence=["#00d4ff"])
        fig.update_layout(
            height=420,
            margin=dict(l=40, r=20, t=60, b=50),
            xaxis_title="Date",
            yaxis_title="Used",
            plot_bgcolor="rgba(0,0,0,0)",
            paper_bgcolor="rgba(0,0,0,0)",
            font_color="#e0e0ff"
        )
        return fig
    except Exception as e:
        print("Trend error:", str(e))
        return px.area(pd.DataFrame({"d":[], "used":[]}), title="No data")

# ================= DASH APP =================
app = Dash(__name__, external_stylesheets=[dbc.themes.LUX])  # Changed to LUX for better visibility (light theme, industry standard)
app.title = "Capacity Management Dashboard"

app.layout = dbc.Container([
    html.H1("Capacity Management Dashboard",
            className="text-center mb-5 mt-3",
            style={"fontWeight": "bold", "letterSpacing": "1px", "color": "#2c3e50", "fontFamily": "Arial, sans-serif"}),

    dbc.Tabs([
        # ── DASHBOARD TAB ───────────────────────────────────────
        dbc.Tab(label="Dashboard", tab_id="dashboard", children=[
            html.H4("Capacity Overview", className="text-center text-primary mt-4 mb-4", style={"fontFamily": "Arial, sans-serif"}),
            dbc.Row(id="kpi-row", className="mb-5 g-4 justify-content-center"),

            html.H4("Usage Trends (Last 30 Days)", className="text-center text-primary mt-4 mb-4", style={"fontFamily": "Arial, sans-serif"}),
            dbc.Row([
                dbc.Col(dcc.Graph(id="cpu-trend"), md=4),
                dbc.Col(dcc.Graph(id="ram-trend"), md=4),
                dbc.Col(dcc.Graph(id="storage-trend"), md=4),
            ], className="g-4")
        ]),

        # ── EVENTS TAB ──────────────────────────────────────────
        dbc.Tab(label="Events", tab_id="events", children=[
            dbc.Row([
                # Left column - Form
                dbc.Col([
                    html.H4("Add Event", className="text-primary mb-4", style={"fontFamily": "Arial, sans-serif"}),
                    dbc.Form([
                        dbc.Label("Server Name (required)", className="text-dark"),
                        dbc.Input(id="server", placeholder="e.g. srv-001", className="mb-3"),

                        dbc.Label("CPU Δ (cores, optional)", className="text-dark"),
                        dbc.Input(id="cpu", type="number", placeholder="positive = add, negative = remove", className="mb-3"),

                        dbc.Label("RAM Δ (GB, optional)", className="text-dark"),
                        dbc.Input(id="ram", type="number", placeholder="+ add / - remove GB", className="mb-3"),

                        dbc.Label("Storage Δ (GB, optional)", className="text-dark"),
                        dbc.Input(id="storage", type="number", placeholder="+ add / - remove GB", className="mb-3"),

                        dbc.Button("Save Event", id="submit", color="primary", className="w-100 mt-2 py-2", n_clicks=0),
                    ]),

                    html.Div(id="msg", className="mt-4"),

                    html.Hr(className="my-4 bg-secondary"),

                    html.H5("Bulk Upload (CSV)", className="text-primary mb-3", style={"fontFamily": "Arial, sans-serif"}),
                    html.P("Columns: date,server,cpu,ram,storage (date=YYYY-MM-DD)", className="text-muted small"),
                    dcc.Upload(
                        id="csv-upload",
                        children=dbc.Button("Upload CSV File", color="info", className="w-100"),
                        style={"width": "100%"},
                        multiple=False
                    ),
                    html.Div(id="csv-msg", className="mt-3")
                ], lg=4, className="p-4 rounded-3 shadow bg-light"),

                # Right column - Tables
                dbc.Col([
                    html.H5("Recent Events (last 10)", className="text-primary mb-3", style={"fontFamily": "Arial, sans-serif"}),
                    html.Div(id="recent-events", className="mb-4"),

                    html.H5("All Events", className="text-primary mb-3", style={"fontFamily": "Arial, sans-serif"}),
                    html.Div(id="event-table")
                ], lg=8)
            ], className="g-4 mt-3")
        ]),

        # ── INVENTORY TAB ───────────────────────────────────────
        dbc.Tab(label="Inventory", tab_id="inventory", children=[
            html.H4("Server Inventory (Read-Only)", className="text-center text-primary mt-4 mb-4", style={"fontFamily": "Arial, sans-serif"}),
            html.Div(id="inventory-table", className="shadow")
        ])
    ], className="mb-5 shadow")

], fluid=True, className="px-4 py-3", style={
    "backgroundColor": "#f8f9fa",  # Light background for better visibility
    "minHeight": "100vh",
    "fontFamily": "Arial, sans-serif",  # Industry standard font
    "color": "#333"  # Dark text for contrast
})

# ================= CALLBACKS =================
@callback(
    [
        Output("kpi-row",         "children"),
        Output("cpu-trend",       "figure"),
        Output("ram-trend",       "figure"),
        Output("storage-trend",   "figure"),
        Output("recent-events",   "children"),
        Output("event-table",     "children"),
        Output("inventory-table", "children"),
        Output("msg",             "children"),
        Output("csv-msg",         "children"),
    ],
    [
        Input("submit",           "n_clicks"),
        Input("csv-upload",       "contents"),
    ],
    [
        State("server",           "value"),
        State("cpu",              "value"),
        State("ram",              "value"),
        State("storage",          "value"),
        State("csv-upload",       "filename"),
    ],
    prevent_initial_call=False
)
def master_callback(submit_clicks, csv_contents,
                    server, cpu, ram, storage, csv_filename):
    
    ctx = callback_context  # Fixed: Use callback_context directly
    triggered_id = ctx.triggered[0]['prop_id'].split('.')[0] if ctx.triggered else ""

    msg_alert = no_update
    csv_alert = no_update

    # 1. Handle manual event submission
    if triggered_id == "submit" and submit_clicks:
        if not server or not str(server).strip():
            msg_alert = dbc.Alert("Server name is required", color="danger", dismissable=True)
        elif not any([cpu, ram, storage]):
            msg_alert = dbc.Alert("At least one of CPU, RAM, or Storage delta must be provided", color="danger", dismissable=True)
        else:
            try:
                with ENGINE.begin() as conn:
                    conn.execute(text("""
                        INSERT INTO capacity_events
                        (assetuniquename, cpu_delta, ram_delta_gb, storage_delta_gb, source)
                        VALUES (:s, :c, :r, :st, 'MANUAL')
                    """), {
                        "s": str(server).strip(),
                        "c": float(cpu or 0),
                        "r": float(ram or 0),
                        "st": float(storage or 0)
                    })
                msg_alert = dbc.Alert("Event saved successfully", color="success", dismissable=True)
            except Exception as e:
                msg_alert = dbc.Alert(f"Error saving event: {str(e)}", color="danger", dismissable=True)

    # 2. Handle CSV upload
    if triggered_id == "csv-upload" and csv_contents is not None:
        try:
            df = parse_csv(csv_contents, csv_filename)
            if df.empty:
                raise ValueError("No valid rows in CSV")
            inserted = 0
            with ENGINE.begin() as conn:
                for _, row in df.iterrows():
                    conn.execute(text("""
                        INSERT INTO capacity_events
                        (assetuniquename, cpu_delta, ram_delta_gb, storage_delta_gb, source, event_time)
                        VALUES (:server, :cpu, :ram, :storage, 'CSV', :dt)
                    """), {
                        "server": row['server'],
                        "cpu": row['cpu'],
                        "ram": row['ram'],
                        "storage": row['storage'],
                        "dt": row['date']
                    })
                    inserted += 1
            csv_alert = dbc.Alert(f"Successfully imported {inserted} rows from {csv_filename}", color="success", dismissable=True)
        except Exception as e:
            csv_alert = dbc.Alert(f"CSV import failed: {str(e)}", color="danger", dismissable=True)

    # 3. Always refresh data
    cap = calculate_capacity()
    kpi_cards = []
    for res, color in [("CPU", "primary"), ("RAM", "info"), ("STORAGE", "success")]:
        d = cap[res]
        bar_color = "danger" if d["pct"] > 85 else "warning" if d["pct"] > 60 else color
        kpi_cards.append(dbc.Col(
            dbc.Card([
                dbc.CardHeader(html.H5(res, className="mb-0", style={"fontFamily": "Arial, sans-serif"})),
                dbc.CardBody([
                    html.P(f"Total: {fmt(d['total'], res)}", className="mb-1"),
                    html.P(f"Reserved: {fmt(d['reserved'], res)}", className="mb-1"),
                    html.P(f"Usable: {fmt(d['usable'], res)}", className="mb-1"),
                    html.P(f"Available: {fmt(d['available'], res)}", className="mb-1"),
                    html.P(f"Used: {fmt(d['used'], res)}", className="mb-2"),
                    dbc.Progress(
                        value=min(d["pct"], 100),
                        color=bar_color,
                        striped=True,
                        animated=d["pct"] > 80,
                        style={"height": "20px"},
                        className="mb-2"
                    ),
                    html.Small(f"Utilization: {d['pct']:.1f}%", className="fw-bold")
                ], className="text-center")
            ], className="shadow border-0"),
            lg=4, md=6, className="mb-4"
        ))

    cpu_fig = build_trend("CPU")
    ram_fig = build_trend("RAM")
    storage_fig = build_trend("STORAGE")

    # Tables
    recent_df = pd.read_sql("""
        SELECT event_time::text AS time,
               assetuniquename AS server,
               cpu_delta AS "Δ CPU",
               ram_delta_gb AS "Δ RAM GB",
               storage_delta_gb AS "Δ Storage GB",
               source
        FROM capacity_events
        ORDER BY event_time DESC
        LIMIT 10
    """, ENGINE)

    events_df = pd.read_sql("""
        SELECT event_time::text AS time,
               assetuniquename AS server,
               cpu_delta AS "Δ CPU",
               ram_delta_gb AS "Δ RAM GB",
               storage_delta_gb AS "Δ Storage GB",
               source
        FROM capacity_events
        ORDER BY event_time DESC
        LIMIT 100
    """, ENGINE)

    inv_df = pd.read_sql("""
        SELECT assetuniquename AS server,
               NULLIF(TRIM(servercores), '') AS cores,
               (NULLIF(TRIM(servermemory), '')::numeric / 1024.0)::text AS "ram_gb",
               NULLIF(TRIM(totaldisk), '') AS "disk_gb"
        FROM inventory
        ORDER BY assetuniquename
    """, ENGINE)

    recent_table = dbc.Table.from_dataframe(recent_df, striped=True, hover=True, responsive=True, className="table table-hover") if not recent_df.empty else html.Div("No recent events", className="text-center text-muted p-4")
    events_table = dbc.Table.from_dataframe(events_df,  striped=True, hover=True, responsive=True, className="table table-hover") if not events_df.empty  else html.Div("No events", className="text-center text-muted p-4")
    inv_table    = dbc.Table.from_dataframe(inv_df,     striped=True, hover=True, responsive=True, className="table table-hover") if not inv_df.empty     else html.Div("No inventory data", className="text-center text-muted p-4")

    return (
        kpi_cards,
        cpu_fig,
        ram_fig,
        storage_fig,
        recent_table,
        events_table,
        inv_table,
        msg_alert,
        csv_alert
    )

# ================= RUN =================
if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8050, debug=False)
