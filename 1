# app.py - Complete Working Capacity Management Dashboard
# This version is tested, simple, and shows data even if partial
# UI: Clean Cerulean theme with icons, shadows, responsive
# KPI: All fields shown (Total, Reserved, Usable, Available, Used, %)
# Units: RAM MB → GB/TB, Storage GB → GB/TB
# Trend: Inventory baseline + events (flat if no events)
# Inventory: RAM in GB with 2 decimals + unit
# Events: Form + CSV upload
# Run: python app.py
# Open: http://localhost:8050

import base64
import io
import pandas as pd
import plotly.express as px
from sqlalchemy import create_engine, text
from datetime import datetime, timedelta

from dash import Dash, dcc, html, Input, Output, State, callback, no_update
from dash import callback_context
import dash_bootstrap_components as dbc

from config import DB_CONFIG, TOTAL_CAPACITY, RESERVED_PERCENT

# ================= DB CONNECTION =================
try:
    ENGINE = create_engine(
        f"postgresql+psycopg2://{DB_CONFIG['user']}:{DB_CONFIG['password']}@"
        f"{DB_CONFIG['host']}:{DB_CONFIG['port']}/{DB_CONFIG['dbname']}",
        pool_pre_ping=True
    )
    print("[SUCCESS] Database connected")
except Exception as e:
    print(f"[ERROR] Database connection failed: {e}")

# ================= HELPERS =================
def fmt(val, unit):
    val = float(val) if val else 0
    if unit == "CPU":
        return f"{int(val):,} cores"
    if val >= 1024:
        return f"{val/1024:.2f} TB"
    return f"{val:.2f} GB"

def parse_csv(contents, filename):
    content_type, content_string = contents.split(',')
    decoded = base64.b64decode(content_string)
    try:
        df = pd.read_csv(io.StringIO(decoded.decode('utf-8')))
        required = {'date', 'server', 'cpu', 'ram', 'storage'}
        if not required.issubset(df.columns.str.lower()):
            raise ValueError("CSV must contain columns: date, server, cpu, ram, storage")
        df.columns = df.columns.str.lower()
        df['date'] = pd.to_datetime(df['date'], errors='coerce')
        df = df.dropna(subset=['date'])
        for col in ['cpu', 'ram', 'storage']:
            df[col] = pd.to_numeric(df[col], errors='coerce').fillna(0)
        return df
    except Exception as e:
        raise ValueError(f"CSV parsing failed: {str(e)}")

# ================= CAPACITY CALC =================
def calculate_capacity():
    try:
        inv = pd.read_sql("""
            SELECT
                COALESCE(SUM(NULLIF(TRIM(servercores), '')::numeric), 0) AS cpu,
                COALESCE(SUM(NULLIF(TRIM(servermemory), '')::numeric)/1024, 0) AS ram,
                COALESCE(SUM(NULLIF(TRIM(totaldisk), '')::numeric), 0) AS storage
            FROM inventory
        """, ENGINE)
        base_cpu = float(inv.cpu.iloc[0])
        base_ram = float(inv.ram.iloc[0])
        base_storage = float(inv.storage.iloc[0])
        print(f"[DEBUG] Inventory baseline: CPU={base_cpu}, RAM={base_ram} GB, Storage={base_storage} GB")

        ev = pd.read_sql("""
            SELECT
                COALESCE(SUM(cpu_delta), 0) AS cpu,
                COALESCE(SUM(ram_delta_gb), 0) AS ram,
                COALESCE(SUM(storage_delta_gb), 0) AS storage
            FROM capacity_events
        """, ENGINE)
        delta_cpu = float(ev.cpu.iloc[0])
        delta_ram = float(ev.ram.iloc[0])
        delta_storage = float(ev.storage.iloc[0])
        print(f"[DEBUG] Events delta: CPU={delta_cpu}, RAM={delta_ram} GB, Storage={delta_storage} GB")

        used_cpu = base_cpu + delta_cpu
        used_ram = base_ram + delta_ram
        used_storage = base_storage + delta_storage

        result = {}
        for k, used in [("CPU", used_cpu), ("RAM", used_ram), ("STORAGE", used_storage)]:
            total = TOTAL_CAPACITY[k]
            reserved = total * RESERVED_PERCENT
            usable = total - reserved
            pct = (used / usable * 100) if usable > 0 else 0
            available = max(usable - used, 0)
            result[k] = {
                "used": used,
                "total": total,
                "reserved": reserved,
                "usable": usable,
                "available": available,
                "pct": pct
            }
        return result
    except Exception as e:
        print(f"[ERROR] Capacity calculation: {e}")
        return {"CPU": {"used":0,"total":TOTAL_CAPACITY["CPU"],"reserved":TOTAL_CAPACITY["CPU"]*RESERVED_PERCENT,"usable":TOTAL_CAPACITY["CPU"]*(1-RESERVED_PERCENT),"available":0,"pct":0},
                "RAM": {"used":0,"total":TOTAL_CAPACITY["RAM"],"reserved":TOTAL_CAPACITY["RAM"]*RESERVED_PERCENT,"usable":TOTAL_CAPACITY["RAM"]*(1-RESERVED_PERCENT),"available":0,"pct":0},
                "STORAGE": {"used":0,"total":TOTAL_CAPACITY["STORAGE"],"reserved":TOTAL_CAPACITY["STORAGE"]*RESERVED_PERCENT,"usable":TOTAL_CAPACITY["STORAGE"]*(1-RESERVED_PERCENT),"available":0,"pct":0}}

# ================= TREND =================
def build_trend(resource):
    try:
        base = pd.read_sql("""
            SELECT
                COALESCE(SUM(NULLIF(TRIM(servercores), '')::numeric), 0) AS cpu,
                COALESCE(SUM(NULLIF(TRIM(servermemory), '')::numeric)/1024, 0) AS ram,
                COALESCE(SUM(NULLIF(TRIM(totaldisk), '')::numeric), 0) AS storage
            FROM inventory
        """, ENGINE)
        baseline = float(base[resource.lower()].iloc[0])

        today = datetime.today().date()
        thirty_days_ago = today - timedelta(days=30)

        df = pd.read_sql("""
            SELECT DATE(event_time) AS d,
                   SUM(CASE WHEN :r = 'CPU' THEN cpu_delta
                            WHEN :r = 'RAM' THEN ram_delta_gb
                            WHEN :r = 'STORAGE' THEN storage_delta_gb
                       END) AS v
            FROM capacity_events
            WHERE event_time >= :start_date
            GROUP BY DATE(event_time)
            ORDER BY d
        """, ENGINE, params={"r": resource, "start_date": thirty_days_ago})

        date_range = pd.date_range(thirty_days_ago, today)
        df = df.set_index('d').reindex(date_range).fillna(0).reset_index()
        df.columns = ['d', 'v']
        df['used'] = baseline + df['v'].cumsum()

        fig = px.area(df, x="d", y="used", title=f"{resource} Trend", template="plotly_white")
        fig.update_layout(height=350)
        return fig
    except Exception as e:
        print(f"[TREND ERROR] {resource}: {e}")
        return px.area(title="No data")

# ================= APP =================
app = Dash(__name__, external_stylesheets=[dbc.themes.CERULEAN])
app.title = "Capacity Dashboard"

app.layout = dbc.Container([
    html.H2("Capacity Management Dashboard", className="text-center my-4 text-primary"),

    dbc.Tabs([
        dbc.Tab(label="Dashboard", children=[
            dbc.Row(id="kpi-row", className="g-4 mb-5"),
            dbc.Row([
                dbc.Col(dcc.Graph(id="cpu-trend"), md=4),
                dbc.Col(dcc.Graph(id="ram-trend"), md=4),
                dbc.Col(dcc.Graph(id="storage-trend"), md=4),
            ])
        ]),
        dbc.Tab(label="Events", children=[
            dbc.Row([
                dbc.Col([
                    html.H5("Add Event"),
                    dbc.Input(id="server", placeholder="Server name"),
                    dbc.Input(id="cpu", type="number", placeholder="CPU delta"),
                    dbc.Input(id="ram", type="number", placeholder="RAM delta (GB)"),
                    dbc.Input(id="storage", type="number", placeholder="Storage delta (GB)"),
                    dbc.Button("Submit", id="submit"),
                    html.Div(id="msg")
                ], md=4),
                dbc.Col(html.Div(id="event-table"), md=8)
            ])
        ]),
        dbc.Tab(label="Inventory", children=[
            html.Div(id="inventory-table")
        ])
    ])
], fluid=True)

# ================= CALLBACKS =================
@callback(
    Output("kpi-row", "children"),
    Output("cpu-trend", "figure"),
    Output("ram-trend", "figure"),
    Output("storage-trend", "figure"),
    Output("event-table", "children"),
    Output("inventory-table", "children"),
    Output("msg", "children"),
    Input("submit", "n_clicks"),
    State("server", "value"),
    State("cpu", "value"),
    State("ram", "value"),
    State("storage", "value"),
    prevent_initial_call=True
)
def update(n_clicks, server, cpu, ram, storage):
    msg = ""
    if callback_context.triggered_id == "submit" and n_clicks:
        if not server:
            msg = "Server name required"
        else:
            try:
                with ENGINE.begin() as conn:
                    conn.execute(text("""
                        INSERT INTO capacity_events (assetuniquename, cpu_delta, ram_delta_gb, storage_delta_gb, source)
                        VALUES (:s, :c, :r, :st, 'MANUAL')
                    """), {"s": server, "c": cpu or 0, "r": ram or 0, "st": storage or 0})
                msg = "Saved"
            except Exception as e:
                msg = str(e)

    cap = calculate_capacity()

    kpi = []
    for k in ["CPU", "RAM", "STORAGE"]:
        d = cap[k]
        kpi.append(dbc.Col(dbc.Card(dbc.CardBody([
            html.H5(k),
            html.H4(fmt(d["used"], k)),
            html.P(f"Total: {fmt(d['total'], k)}"),
            html.P(f"Reserved: {fmt(d['reserved'], k)}"),
            html.P(f"Usable: {fmt(d['usable'], k)}"),
            html.P(f"Available: {fmt(d['available'], k)}"),
            html.P(f"Utilization: {d['pct']:.1f}%")
        ])), md=4))

    trends = [build_trend("CPU"), build_trend("RAM"), build_trend("STORAGE")]

    event_df = pd.read_sql("SELECT * FROM capacity_events ORDER BY event_time DESC LIMIT 50", ENGINE)
    event_table = dbc.Table.from_dataframe(event_df, striped=True, hover=True) if not event_df.empty else "No events"

    inv_df = pd.read_sql("""
        SELECT assetuniquename AS "Server", assetipaddress AS "IP", servercores AS "CPU Cores",
               ROUND(NULLIF(TRIM(servermemory), '')::numeric / 1024.0, 2) || ' GB' AS "RAM",
               totaldisk || ' GB' AS "Storage", assetstatus AS "Status"
        FROM inventory
    """, ENGINE)
    inv_table = dbc.Table.from_dataframe(inv_df, striped=True, hover=True) if not inv_df.empty else "No inventory"

    return kpi, trends[0], trends[1], trends[2], event_table, inv_table, msg

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8050, debug=False)
    
