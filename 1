import sqlite3
from datetime import datetime

import altair as alt
import pandas as pd
import streamlit as st

DB_PATH = "metrics.db"  # path to your SQLite DB file


# ======================
# DB & DATA HELPERS
# ======================

@st.cache_resource
def get_connection():
    return sqlite3.connect(DB_PATH)


@st.cache_data
def get_os_types():
    conn = get_connection()
    df = pd.read_sql_query(
        "SELECT DISTINCT os_type FROM server_daily_metrics ORDER BY os_type;",
        conn,
    )
    return df["os_type"].tolist()


@st.cache_data
def get_dates():
    conn = get_connection()
    df = pd.read_sql_query(
        "SELECT DISTINCT metric_date FROM server_daily_metrics ORDER BY metric_date DESC;",
        conn,
    )
    return df["metric_date"].tolist()


@st.cache_data
def load_data(os_type: str, metric_date: str):
    conn = get_connection()
    query = """
        SELECT
            metric_date,
            instance,
            os_type,
            max_cpu,
            avg_cpu,
            max_mem,
            avg_mem,
            disk_util
        FROM server_daily_metrics
        WHERE os_type = ?
          AND metric_date = ?
        ORDER BY instance;
    """
    df = pd.read_sql_query(query, conn, params=(os_type, metric_date))

    # Ensure numeric types
    for col in ["max_cpu", "avg_cpu", "max_mem", "avg_mem", "disk_util"]:
        if col in df.columns:
            df[col] = pd.to_numeric(df[col], errors="coerce")

    return df


# ======================
# STREAMLIT APP
# ======================

def main():
    st.set_page_config(
        page_title="Server Performance Dashboard",
        layout="wide",
    )

    st.title("üìä Server Performance Dashboard")
    st.caption("Data source: metrics.db (SQLite) loaded from daily CSVs (Windows & Linux)")

    # ------------------
    # Sidebar Filters
    # ------------------
    st.sidebar.header("Filters")

    os_types = get_os_types()
    if not os_types:
        st.error("‚ùå No OS types found in database. Check metrics.db / ETL.")
        return

    selected_os = st.sidebar.selectbox("OS Type", os_types, index=0, help="Choose Windows or Linux data")

    dates = get_dates()
    if not dates:
        st.error("‚ùå No dates found in database.")
        return

    selected_date = st.sidebar.selectbox("Metric Date", dates, index=0, help="Data is shown only for this date")

    instance_filter = st.sidebar.text_input(
        "Filter by instance (optional)",
        value="",
        help="Type part of server name or IP to filter the table & charts",
    )

    # Load data
    df = load_data(selected_os, selected_date)

    if df.empty:
        st.warning(f"No rows found for OS = {selected_os}, Date = {selected_date}")
        return

    if instance_filter.strip():
        df = df[df["instance"].str.contains(instance_filter.strip(), case=False, na=False)]

    if df.empty:
        st.warning("No rows match the instance filter.")
        return

    st.markdown(
        f"### üîé View for **OS = `{selected_os}`**, **Date = `{selected_date}`**  "
    )

    # ------------------
    # KPI Cards
    # ------------------
    col1, col2, col3, col4 = st.columns(4)

    with col1:
        st.metric(
            "Avg Max CPU (%)",
            f"{df['max_cpu'].mean():.2f}" if not df['max_cpu'].isna().all() else "N/A",
        )
    with col2:
        st.metric(
            "Avg Max Memory (%)",
            f"{df['max_mem'].mean():.2f}" if not df['max_mem'].isna().all() else "N/A",
        )
    with col3:
        st.metric(
            "Avg Disk Util (%)",
            f"{df['disk_util'].mean():.2f}" if 'disk_util' in df.columns and not df['disk_util'].isna().all() else "N/A",
        )
    with col4:
        st.metric("Total Instances", len(df))

    st.markdown("---")

    # ------------------
    # Charts
    # ------------------
    st.subheader("üìà Top Resource Usage (Selected Date)")

    left, right = st.columns(2)

    # Top 10 by Max CPU
    with left:
        st.markdown("**Top 10 Instances by Max CPU (%)**")
        top_cpu = df.sort_values("max_cpu", ascending=False).head(10).copy()
        if not top_cpu.empty and not top_cpu["max_cpu"].isna().all():
            cpu_chart = (
                alt.Chart(top_cpu)
                .mark_bar()
                .encode(
                    x=alt.X("max_cpu:Q", title="Max CPU (%)"),
                    y=alt.Y("instance:N", sort="-x", title="Instance"),
                    tooltip=["instance", "max_cpu", "avg_cpu"],
                )
                .properties(height=350)
            )
            st.altair_chart(cpu_chart, use_container_width=True)
        else:
            st.info("No CPU data available for chart.")

    # Top 10 by Max Memory
    with right:
        st.markdown("**Top 10 Instances by Max Memory (%)**")
        top_mem = df.sort_values("max_mem", ascending=False).head(10).copy()
        if not top_mem.empty and not top_mem["max_mem"].isna().all():
            mem_chart = (
                alt.Chart(top_mem)
                .mark_bar()
                .encode(
                    x=alt.X("max_mem:Q", title="Max Memory (%)"),
                    y=alt.Y("instance:N", sort="-x", title="Instance"),
                    tooltip=["instance", "max_mem", "avg_mem"],
                )
                .properties(height=350)
            )
            st.altair_chart(mem_chart, use_container_width=True)
        else:
            st.info("No Memory data available for chart.")

    st.markdown("---")

    # ------------------
    # Detailed Table
    # ------------------
    st.subheader("üìã Detailed Metrics Table")

    display_df = df.rename(
        columns={
            "instance": "Instance",
            "os_type": "OS",
            "max_cpu": "Max CPU (%)",
            "avg_cpu": "Avg CPU (%)",
            "max_mem": "Max Memory (%)",
            "avg_mem": "Avg Memory (%)",
            "disk_util": "Disk Util (%)",
        }
    )

    st.dataframe(
        display_df,
        use_container_width=True,
        height=450,
    )

    # Optional: Allow export
    csv_export = display_df.to_csv(index=False).encode("utf-8")
    st.download_button(
        label="‚¨áÔ∏è Download this table as CSV",
        data=csv_export,
        file_name=f"metrics_{selected_os}_{selected_date}.csv",
        mime="text/csv",
    )


if __name__ == "__main__":
    main()
