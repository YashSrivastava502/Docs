# ==========================
# DNS Failover Automation
# Author: Yash Srivastava
# Date: (auto)
# ==========================

$dc1 = "usel-pr-dc1"                          # Primary DC hostname
$dnsServer = $env:COMPUTERNAME
$timestamp = (Get-Date).ToString("yyyyMMdd_HHmmss")
$backupDir = "C:\Scripts"
$backupPath = Join-Path $backupDir "ARecords_Backup_$timestamp.csv"
$unmatchedPath = Join-Path $backupDir "Unmatched_Records_$timestamp.txt"
$mappingFile = "C:\Scripts\dr_mapping.csv"    # Your mapping file

Write-Host "`n===== DNS FAILOVER SCRIPT STARTED =====`n"

# Step 1️: Check DC connectivity
if (!(Test-Connection -ComputerName $dc1 -Count 2 -Quiet)) {
    Write-Host " $dc1 is not reachable — Starting failover mode..."
} else {
    Write-Host " $dc1 is reachable — Failover skipped."
    exit
}

# Step 2️: Load custom mapping
$customMap = @{}
if (Test-Path $mappingFile) {
    $mapData = Import-Csv $mappingFile
    foreach ($row in $mapData) {
        $customMap[$row.OriginalName.ToLower()] = $row.DRName
    }
    Write-Host " Loaded $($customMap.Count) custom DR mappings from $mappingFile"
} else {
    Write-Warning " Mapping file not found at $mappingFile — only pattern-based matching will be used."
}

# Step 3️: Take full backup of A records
$zones = Get-DnsServerZone
$allRecords = @()

foreach ($zone in $zones) {
    $aRecords = Get-DnsServerResourceRecord -ZoneName $zone.ZoneName -RRType A -ErrorAction SilentlyContinue
    foreach ($rec in $aRecords) {
        $recordIP = $null
        try { $recordIP = $rec.RecordData.IPv4Address.ToString() } catch {}
        if ($recordIP) {
            $allRecords += [PSCustomObject]@{
                Zone = $zone.ZoneName
                Name = $rec.HostName
                IP   = $recordIP
            }
        }
    }
}

$allRecords | Export-Csv $backupPath -NoTypeInformation
Write-Host " Full A record backup saved to: $backupPath"

# Step 4️: Process and perform failover
$unmatched = @()

foreach ($rec in $allRecords) {
    $zone = $rec.Zone
    $name = $rec.Name
    $targetDR = $null

    # --- Skip already DR records ---
    if ($name -match '^(az|AZ|sql-|SQL-|.*-dr)$') {
        continue
    }

    # --- 1️ Check in CSV mapping ---
    if ($customMap.ContainsKey($name.ToLower())) {
        $targetDR = $customMap[$name.ToLower()]
    }
    # --- 2️ Pattern match rules ---
    elseif ($name -match '^(mongo|mongodb)-(.+)$') {
        $targetDR = "az$($Matches[2])"
    }
    elseif ($name -match '^(NJ|nj)(.+)$') {
        $targetDR = "AZ$($Matches[2])"
    }

    # --- 3️ Create CNAME if DR found ---
    if ($targetDR) {
        try {
            # Delete original A record
            Remove-DnsServerResourceRecord -ZoneName $zone -Name $name -RRType A -Force -ErrorAction Stop

            # Create CNAME pointing to DR (add FQDN if zone-based)
            $alias = if ($targetDR -match "\.") { $targetDR } else { "$targetDR.$zone" }

            Add-DnsServerResourceRecordCName -ZoneName $zone -Name $name -HostNameAlias $alias -ErrorAction Stop
            Write-Host " Created CNAME: $name → $alias in zone $zone"
        }
        catch {
            Write-Warning " Failed to create CNAME for $name in $zone: $_"
        }
    }
    else {
        # No match found
        $unmatched += "$($name).$zone"
    }
}

# Step : Save unmatched hostnames
if ($unmatched.Count -gt 0) {
    $unmatched | Out-File -FilePath $unmatchedPath -Encoding utf8
    Write-Host "`n $($unmatched.Count) records had no DR match. Saved to: $unmatchedPath"
} else {
    Write-Host "`n All records successfully mapped to DR."
}

Write-Host "`n✔ Failover complete: Backup, CNAME mapping, and unmatched logging done."
Write-Host "===== SCRIPT END =====`n"

